package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"regexp"
	"strconv"
	"time"

	"github.com/shieldoo/shieldoo-mesh-admin/graph/generated"
	gqlmodel "github.com/shieldoo/shieldoo-mesh-admin/graph/model"
	"github.com/shieldoo/shieldoo-mesh-admin/logstore"
	"github.com/shieldoo/shieldoo-mesh-admin/model"
	"github.com/shieldoo/shieldoo-mesh-admin/myjwt"
	"github.com/shieldoo/shieldoo-mesh-admin/utils"
	log "github.com/sirupsen/logrus"
)

// SystemConfigSave is the resolver for the systemConfigSave field.
func (r *mutationResolver) SystemConfigSave(ctx context.Context, data gqlmodel.SystemConfigData) (*gqlmodel.SystemConfig, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	err := model.SystemConfigApplyCIDR(data.NetworkCidr)
	c := modelconvSystemConfig2Gql(*model.SystemConfig())
	return &c, err
}

// SystemAadConfigSave is the resolver for the systemAadConfigSave field.
func (r *mutationResolver) SystemAadConfigSave(ctx context.Context, data gqlmodel.AadConfigData) (*gqlmodel.AadConfig, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}

	var err error
	syscfg := model.SystemConfig()
	secret := syscfg.AADSyncConfig.AADClientSecret

	// check inputs
	if data.IsEnabled {
		if data.TenantID == "" {
			return nil, errors.New("AAD Tenant ID is required")
		}
		if data.ClientID == "" {
			return nil, errors.New("AAD Client ID is required")
		}
		if secret == "" && data.ClientSecret == "" {
			return nil, errors.New("AAD Client Secret is required")
		}
		if data.AdminGroupObjectID == "" {
			return nil, errors.New("AAD Admin Group Object ID is required")
		}
	}

	ret := gqlmodel.AadConfig{
		IsEnabled: data.IsEnabled,
		TenantID:  data.TenantID,
		ClientID:  data.ClientID,
		// ClientSecret: data.ClientSecret,
		AdminGroupObjectID: data.AdminGroupObjectID,
	}

	// if enabled, try to connect and process test load
	if data.IsEnabled {
		if data.ClientSecret != "" {
			secret = data.ClientSecret
		}
		succes, msg := aadLoadDryRun(data.TenantID, data.ClientID, secret, data.AdminGroupObjectID)
		log.Debug("AAD dry run result: ", succes, msg)
		if succes {
			err = model.SystemConfigApplyAadSyncConfig(model.AADSyncConfig{
				Enabled:         true,
				AADTenantID:     data.TenantID,
				AADClientID:     data.ClientID,
				AADClientSecret: secret,
				AdminGroupID:    data.AdminGroupObjectID,
			})
			utils.BreakAADWaitLoop()
			if err == nil {
				ret.LastProcessingMessage = "OK: " + msg
			} else {
				ret.LastProcessingMessage = "ERROR: " + msg
			}
		} else {
			ret.LastProcessingMessage = "ERROR: " + msg
		}
		model.DacSaveKey(keyStoreKey, "AAD Import enabled")
	} else {
		err = model.SystemConfigApplyAadSyncConfig(
			model.AADSyncConfig{
				Enabled: false,
			})
		if err == nil {
			ret.LastProcessingMessage = "OK: AAD sync disabled"
		} else {
			ret.LastProcessingMessage = "ERROR: AAD sync disabling failed"
		}
		model.DacSaveKey(keyStoreKey, "AAD Import disabled")
	}

	return &ret, err
}

// SystemCliAPIConfigSave is the resolver for the systemCliApiConfigSave field.
func (r *mutationResolver) SystemCliAPIConfigSave(ctx context.Context, data gqlmodel.CliAPIConfigData) (*gqlmodel.CliAPIConfig, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	err := model.SystemConfigApplyCliApiConfig(data.Enabled)
	c := modelconvSystemConfig2Gql(*model.SystemConfig())
	// put full apikey to response
	c.CliAPIConfig.APIKey = model.SystemConfig().CliApiConfig.ApiKey
	return c.CliAPIConfig, err
}

// UserInvite is the resolver for the userInvite field.
func (r *mutationResolver) UserInvite(ctx context.Context, data gqlmodel.InviteUserData) (*gqlmodel.User, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	upn := myjwt.ClaimUserNameFromContext(ctx)
	var err error
	var m model.Entity
	// prepare old object for loging
	o := m
	// convert gql input data
	modelconvGqlInvite2UserEntity(data, &m)
	// if there is template_id than we can use it
	var templateId int
	if data.UserAccessTemplateID != nil {
		templateId = *data.UserAccessTemplateID
	} else {
		templateId = model.ENTITY_DEFAULTTEMPLATE_ID
	}
	err = model.DacInviteUser(upn, templateId, &m, &o)
	if err == nil {
		go model.LogStoreDatachange(
			logstoreInsertOrUpdate(data.ID),
			myjwt.ClaimUserNameFromContext(ctx),
			m, o)
		// send invitation email
		go model.SendInvitationEmail(m.UPN)
	}
	ret := modelconvEntityUser2Gql(m)
	return &ret, err
}

// ServerDelete is the resolver for the serverDelete field.
func (r *mutationResolver) ServerDelete(ctx context.Context, id int) (*gqlmodel.Server, error) {
	ent := gqlmodel.Server{ID: id}
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return &ent, accerr
	}
	old, err := model.DacEntityGet(id)
	if err != nil {
		return &ent, err
	}
	if old.EntityType != model.ENTITY_SERVER {
		return &ent, fmt.Errorf("entity is not server")
	}
	err = model.DacEntityDelete(id, myjwt.ClaimUserNameFromContext(ctx))
	if err != nil {
		return &ent, err
	}
	go model.LogStoreDatachange(logstore.LOGTYPE_DATADELETE, myjwt.ClaimUserNameFromContext(ctx), &old, nil)
	return &ent, nil
}

// UserDelete is the resolver for the userDelete field.
func (r *mutationResolver) UserDelete(ctx context.Context, id int) (*gqlmodel.User, error) {
	ent := gqlmodel.User{ID: id}
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return &ent, accerr
	}
	old, err := model.DacEntityGet(id)
	if err != nil {
		return &ent, err
	}
	if old.EntityType != model.ENTITY_USER {
		return &ent, fmt.Errorf("entity is not user")
	}
	err = model.DacEntityDelete(id, myjwt.ClaimUserNameFromContext(ctx))
	if err != nil {
		return &ent, err
	}
	go model.LogStoreDatachange(logstore.LOGTYPE_DATADELETE, myjwt.ClaimUserNameFromContext(ctx), &old, nil)
	return &ent, nil
}

// ServerSave is the resolver for the serverSave field.
func (r *mutationResolver) ServerSave(ctx context.Context, data *gqlmodel.ServerData) (*gqlmodel.Server, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	if data == nil {
		return nil, fmt.Errorf("no input data")
	}
	// check name regex
	re := regexp.MustCompile(`^[0-9a-zA-Z-.]{1,256}$`)
	if !re.MatchString(data.Name) {
		return nil, fmt.Errorf("Name is not valid - contains invalid characters")
	}

	upn := myjwt.ClaimUserNameFromContext(ctx)
	var err error
	var m model.Entity
	var ma model.Access
	var oa model.Access
	var updPolicy model.OSAutoupdateConfigType
	var inpAccess *gqlmodel.ServerAccessData
	if data.ID == nil {
		// create default access if is not set for new server
		if data.Access == nil {
			inpAccess = &gqlmodel.ServerAccessData{
				FwConfigID: model.ENTITY_DEFAULTFIREWALL_ID,
				ValidTo:    convertDateJson(model.SystemConfig().CA.ValidTo),
			}
		} else {
			inpAccess = data.Access
		}
	} else {
		m, err = model.DacEntityGet(*data.ID)
		if err != nil {
			return nil, err
		}
		// business logic checks
		if m.EntityType != model.ENTITY_SERVER {
			return nil, fmt.Errorf("Original entity is not Server.")
		}
		// try to find access on server
		var accid int
		accid, err = model.DacFirstAccessIdByEntityID(*data.ID)
		if err != nil {
			return nil, err
		}
		if accid == 0 {
			inpAccess = &gqlmodel.ServerAccessData{
				FwConfigID: model.ENTITY_DEFAULTFIREWALL_ID,
				ValidTo:    convertDateJson(model.SystemConfig().CA.ValidTo),
			}
		} else {
			ma, err = model.DacAccessGet(accid)
			if err != nil {
				return nil, err
			}
			oa, err = model.DacAccessGet(accid)
			if err != nil {
				return nil, err
			}
			if data.Access == nil {
				// access not send from server, we have to update it
				inpAccess = &gqlmodel.ServerAccessData{
					IPAddress:          &ma.IpAddress,
					Description:        &ma.Description,
					FwConfigID:         ma.FwconfigID,
					ValidTo:            convertDateJson(ma.ValidTo),
					PunchBack:          *ma.NebulaPunchBack,
					RestrictiveNetwork: *ma.NebulaRestrictiveNetwork,
				}
				for _, g := range ma.AccessGroups {
					inpAccess.GroupsIds = append(inpAccess.GroupsIds, g.GroupID)
				}
				for _, list := range ma.AccessListeners {
					inpAccess.Listeners = append(inpAccess.Listeners, &gqlmodel.AccessListenerData{
						ListenPort:           list.ListenPort,
						Protocol:             list.Protocol,
						ForwardPort:          list.ForwardPort,
						ForwardHost:          list.ForwardHost,
						AccessListenerTypeID: list.AccessListenerTypeID,
						Description:          list.Description,
					})
				}
			} else {
				inpAccess = data.Access
			}
		}
	}
	// prepare old object for loging
	o := m
	// convert gql input data
	modelconvGql2ServerEntity(data, &m)
	modelconvGqlServerAccess2Access(m.ID, ma.ID, *inpAccess, data.Name, data.AllowAutoUpdate, &ma)
	if data.OsAutoUpdatePolicy != nil {
		updPolicy.Enabled = data.OsAutoUpdatePolicy.OsAutoUpdateEnabled
		updPolicy.UpdateHour = data.OsAutoUpdatePolicy.OsAutoUpdateHour
		updPolicy.SecurityAutoupdateEnabled = data.OsAutoUpdatePolicy.SecurityAutoUpdateEnabled
		updPolicy.AllAutoupdateEnabled = data.OsAutoUpdatePolicy.AllAutoUpdateEnabled
		updPolicy.RestartAfterUpdate = data.OsAutoUpdatePolicy.RestartAfterUpdate
		// serialize auto update policy to string
		updPolicyJson, err := json.Marshal(&updPolicy)
		if err == nil {
			ma.OSAutoupdateConfig = string(updPolicyJson)
		}
	}
	err = model.DacEntityServerSave(upn, &m, &o, &ma, &oa)
	if err == nil {
		go model.LogStoreDatachange(
			logstoreInsertOrUpdate(data.ID),
			myjwt.ClaimUserNameFromContext(ctx),
			m, o)
		ma.Certificate.SecretCrt = "***"
		ma.Certificate.SecretKey = "***"
		oa.Certificate.SecretCrt = "***"
		oa.Certificate.SecretKey = "***"
		go model.LogStoreDatachange(
			logstoreInsertOrUpdate(data.ID),
			myjwt.ClaimUserNameFromContext(ctx),
			ma, oa)
	}
	ret := modelconvEntityServer2Gql(m)
	reta := modelconvAccess2Gql(ma)
	ret.Access = &reta
	return &ret, err
}

// UserSave is the resolver for the userSave field.
func (r *mutationResolver) UserSave(ctx context.Context, data gqlmodel.UserData) (*gqlmodel.User, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	upn := myjwt.ClaimUserNameFromContext(ctx)
	var err error
	var m model.Entity
	if data.ID != nil {
		m, err = model.DacEntityGet(*data.ID)
		if err != nil {
			return nil, err
		}
		// business logic checks
		if m.EntityType != model.ENTITY_USER {
			return nil, fmt.Errorf("Original entity is not User.")
		}
		// if you are trying to leave ADMINISTRATOR role for self or trying to change upn for self
		if upn == m.UPN {
			if m.UPN != data.Upn {
				return nil, fmt.Errorf("Users' UPN cannot be changed for logged in user.")
			}
			origadmin := false
			for _, i := range modelconvUserRoles2Gql(m.Roles) {
				if *i == model.ROLE_ADMINISTRATOR {
					origadmin = true
					break
				}
			}
			if origadmin {
				newadmin := false
				for _, i := range data.Roles {
					if *i == model.ROLE_ADMINISTRATOR {
						newadmin = true
						break
					}
				}
				if !newadmin {
					return nil, fmt.Errorf("Current logged in user is ADMINISTRATOR and cannot be unassigned from this role.")
				}
			}
		}
	}
	// prepare old object for loging
	o := m
	// convert gql input data
	modelconvGql2UserEntity(data, &m)
	isnew := m.ID == 0
	if isnew {
		m.Origin = "invited"
	}
	err = model.DacEntitySave(upn, &m, &o)
	ret := modelconvEntityUser2Gql(m)
	if err == nil {
		go model.LogStoreDatachange(
			logstoreInsertOrUpdate(data.ID),
			myjwt.ClaimUserNameFromContext(ctx),
			m, o)
		if isnew {
			go model.SendInvitationEmail(m.UPN)
		}
	}
	return &ret, err
}

// GroupDelete is the resolver for the groupDelete field.
func (r *mutationResolver) GroupDelete(ctx context.Context, id int) (*gqlmodel.Group, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return &gqlmodel.Group{ID: id}, accerr
	}
	old, err := model.DacGroupGet(id)
	if err != nil {
		return &gqlmodel.Group{ID: id}, err
	}
	err = model.DacGroupDelete(id, myjwt.ClaimUserNameFromContext(ctx))
	if err != nil {
		return &gqlmodel.Group{ID: id}, err
	}
	go model.LogStoreDatachange(logstore.LOGTYPE_DATADELETE, myjwt.ClaimUserNameFromContext(ctx), &old, nil)
	return &gqlmodel.Group{ID: id}, nil
}

// GroupSave is the resolver for the groupSave field.
func (r *mutationResolver) GroupSave(ctx context.Context, data gqlmodel.GroupData) (*gqlmodel.Group, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	var err error
	var m model.Group
	if data.ID != nil {
		m, err = model.DacGroupGet(*data.ID)
		if err != nil {
			return nil, err
		}
		// business logic check
		if data.Name != m.Name {
			return nil, fmt.Errorf("Changing the group name is not allowed.")
		}
	}
	// prepare old object for loging
	o := m
	// convert gql input data
	modelconvGql2Group(data, &m)
	err = model.DacGroupSave(myjwt.ClaimUserNameFromContext(ctx), &m)
	ret := modelconvGroup2Gql(m)
	if err == nil {
		go model.LogStoreDatachange(
			logstoreInsertOrUpdate(data.ID),
			myjwt.ClaimUserNameFromContext(ctx),
			m, o)
	}
	return &ret, err
}

// UserAccessTemplateDelete is the resolver for the userAccessTemplateDelete field.
func (r *mutationResolver) UserAccessTemplateDelete(ctx context.Context, id int) (*gqlmodel.UserAccessTemplate, error) {
	uat := gqlmodel.UserAccessTemplate{ID: id}
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return &uat, accerr
	}
	old, err := model.DacUserAccessTemplateGet(id)
	if err != nil {
		return &uat, err
	}
	if old.ID == model.ENTITY_DEFAULTTEMPLATE_ID {
		return &uat, fmt.Errorf("default template cannot be deleted")
	}
	err = model.DacUserAccessTemplateDelete(id, myjwt.ClaimUserNameFromContext(ctx))
	if err != nil {
		return &uat, err
	}
	go model.LogStoreDatachange(logstore.LOGTYPE_DATADELETE, myjwt.ClaimUserNameFromContext(ctx), &old, nil)
	return &uat, nil
}

// UserAccessTemplateSave is the resolver for the userAccessTemplateSave field.
func (r *mutationResolver) UserAccessTemplateSave(ctx context.Context, data gqlmodel.UserAccessTemplateData) (*gqlmodel.UserAccessTemplate, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	var err error
	var o model.UserAccessTemplate
	if data.ID != nil {
		o, err = model.DacUserAccessTemplateGet(*data.ID)
		if err != nil {
			return nil, err
		}
	}
	// prepare old object for loging
	m := o
	// convert gql input data
	m.UserAccessTemplateGroups = []model.UserAccessTemplateGroup{}
	modelconvGql2UserAccessTemplate(data, &m)
	err = model.DacUserAccessTemplateSave(myjwt.ClaimUserNameFromContext(ctx), &m)
	if err == nil {
		m, err = model.DacUserAccessTemplateGet(m.ID)
	}
	if err == nil {
		go model.LogStoreDatachange(
			logstoreInsertOrUpdate(data.ID),
			myjwt.ClaimUserNameFromContext(ctx),
			m, o)
	}
	ret := modelconvUserAccessTemplate2Gql(m)
	return &ret, err
}

// FirewallConfigurationDelete is the resolver for the firewallConfigurationDelete field.
func (r *mutationResolver) FirewallConfigurationDelete(ctx context.Context, id int) (*gqlmodel.FwConfig, error) {
	fw := gqlmodel.FwConfig{ID: id}
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return &fw, accerr
	}
	old, err := model.DacFwconfigGet(id)
	if err != nil {
		return &fw, err
	}
	err = model.DacFwconfigDelete(id, myjwt.ClaimUserNameFromContext(ctx))
	if err != nil {
		return &fw, err
	}
	utils.BreakAADWaitLoop()
	go model.LogStoreDatachange(logstore.LOGTYPE_DATADELETE, myjwt.ClaimUserNameFromContext(ctx), &old, nil)
	return &fw, nil
}

// FirewallConfigurationSave is the resolver for the firewallConfigurationSave field.
func (r *mutationResolver) FirewallConfigurationSave(ctx context.Context, data gqlmodel.FwConfigData) (*gqlmodel.FwConfig, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	var err error
	var o model.Fwconfig
	if data.ID != nil {
		o, err = model.DacFwconfigGet(*data.ID)
		if err != nil {
			return nil, err
		}
	}
	// prepare old object for loging
	m := o
	// convert gql input data
	modelconvGql2Fwconfig(data, &m)
	err = model.DacFwconfigSave(myjwt.ClaimUserNameFromContext(ctx), &m)
	if err == nil {
		m, err = model.DacFwconfigGet(m.ID)
	}
	if err == nil {
		go model.LogStoreDatachange(
			logstoreInsertOrUpdate(data.ID),
			myjwt.ClaimUserNameFromContext(ctx),
			m, o)
	}
	utils.BreakAADWaitLoop()
	ret := modelconvFwConfig2Gql(m)
	return &ret, err
}

// UserAccessDelete is the resolver for the userAccessDelete field.
func (r *mutationResolver) UserAccessDelete(ctx context.Context, id int) (*gqlmodel.UserAccess, error) {
	ua := gqlmodel.UserAccess{ID: id}
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return &ua, accerr
	}
	old, err := model.DacUserAccessGet(id)
	if err != nil {
		return &ua, err
	}
	err = model.DacUserAccessDelete(id, myjwt.ClaimUserNameFromContext(ctx))
	if err != nil {
		return &ua, err
	}
	go model.LogStoreDatachange(logstore.LOGTYPE_DATADELETE, myjwt.ClaimUserNameFromContext(ctx), &old, nil)
	return &ua, nil
}

// UserAccessSave is the resolver for the userAccessSave field.
func (r *mutationResolver) UserAccessSave(ctx context.Context, data gqlmodel.UserAccessData) (*gqlmodel.UserAccess, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	var old model.UserAccess
	var m model.UserAccess
	var err error
	if data.ID != nil {
		old, err = model.DacUserAccessGet(*data.ID)
		if err != nil {
			return nil, err
		}
		m, err = model.DacUserAccessGet(*data.ID)
		if err != nil {
			return nil, err
		}
	}

	modelconvGqlUserAccess2UserAccess(data, &m)
	err = model.DacUserAccessSave(myjwt.ClaimUserNameFromContext(ctx), &m, &old)
	if err != nil {
		return nil, err
	}
	if err == nil {
		go model.LogStoreDatachange(
			logstoreInsertOrUpdate(data.ID),
			myjwt.ClaimUserNameFromContext(ctx),
			m, old)
	}
	ret := modelconvUserAccess2Gql(m)
	return &ret, err
}

// UserDeviceSaveNote is the resolver for the userDeviceSaveNote field.
func (r *mutationResolver) UserDeviceSaveNote(ctx context.Context, id int, note string) (*gqlmodel.Access, error) {
	var a gqlmodel.Access
	if accerr := checkAdminOrAccess(ctx, id); accerr != nil {
		return &a, accerr
	}
	old, err := model.DacAccessGet(id)

	if err != nil {
		return &a, err
	}

	err = model.DacAccessSaveNote(myjwt.ClaimUserNameFromContext(ctx), id, note)

	if err != nil {
		return &a, err
	}

	cur, err := model.DacAccessGet(id)

	if err != nil {
		return &a, err
	}

	cur.Description = note
	acc := modelconvAccess2Gql(cur)
	go model.LogStoreDatachange(logstore.LOGTYPE_DATAUPDATE, myjwt.ClaimUserNameFromContext(ctx), cur, old)
	return &acc, nil
}

// UserDeviceDelete is the resolver for the userDeviceDelete field.
func (r *mutationResolver) UserDeviceDelete(ctx context.Context, id int) (int, error) {
	if accerr := checkAdminOrAccess(ctx, id); accerr != nil {
		return 0, accerr
	}
	old, err := model.DacAccessGet(id)
	if err != nil {
		return 0, err
	}
	err = model.DacAccessDelete(id, myjwt.ClaimUserNameFromContext(ctx))
	if err != nil {
		return 0, err
	}
	go model.LogStoreDatachange(logstore.LOGTYPE_DATADELETE, myjwt.ClaimUserNameFromContext(ctx), &old, nil)
	return id, err
}

// UserDeviceCreate is the resolver for the userDeviceCreate field.
func (r *mutationResolver) UserDeviceCreate(ctx context.Context, userAccessID int, data gqlmodel.AccessDeviceData, publicKey *string) (*gqlmodel.UserAccessDeviceInfo, error) {
	if accerr := checkAdminOrUserAccess(ctx, userAccessID); accerr != nil {
		return nil, accerr
	}
	access, certificate, err := model.DacAccessCreateForUser(
		myjwt.ClaimUserNameFromContext(ctx),
		userAccessID,
		data.DeviceID, data.Name, data.DeviceOSType+", "+data.DeviceOs, data.DeviceSWVersion,
		*publicKey)
	if err != nil {
		return nil, err
	}
	gaccess := modelconvAccess2Gql(access)
	return &gqlmodel.UserAccessDeviceInfo{
		Access:              &gaccess,
		Certificate:         certificate,
		CaPublicKey:         model.SystemConfig().CA.Crt,
		LighthouseIP:        model.SystemConfig().Lighthouses[0].PublicIP,
		LighthousePort:      model.SystemConfig().Lighthouses[0].Port,
		LighthousePrivateIP: model.SystemConfig().Lighthouses[0].Access.IpAddress,
	}, err
}

// MonthCostUsage is the resolver for the monthCostUsage field.
func (r *queryResolver) MonthCostUsage(ctx context.Context) ([]*gqlmodel.CostUsageMonthItem, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	monthItems, err := model.DacGetCostUsage()
	if err != nil {
		return nil, err
	}
	// convert to gqlmodel
	var ret []*gqlmodel.CostUsageMonthItem
	for _, item := range monthItems {
		var resourceItems []*gqlmodel.CostUsageItem
		for _, resourceItem := range item.UsageItems {
			resourceItems = append(resourceItems, &gqlmodel.CostUsageItem{
				YearMonth: resourceItem.YearMonth,
				Upn:       resourceItem.Upn,
				IsUser:    resourceItem.IsUser,
				Hours:     float64(resourceItem.HoursUsed),
				Cost:      resourceItem.Cost,
			})
		}
		ret = append(ret, &gqlmodel.CostUsageMonthItem{
			YearMonth:      item.YearMonth,
			Cost:           item.Cost,
			CostUsageItems: resourceItems,
		})
	}
	return ret, nil
}

// Config is the resolver for the config field.
func (r *queryResolver) Config(ctx context.Context) (*gqlmodel.ConfigItem, error) {
	if accerr := myjwt.JwtRoleCheckerContextUSER(ctx); accerr != nil {
		return nil, accerr
	}
	ret := gqlmodel.ConfigItem{
		MaxDBRecords:           _cfg.Database.MaxRecords,
		TenantID:               _cfg.Auth.Shieldoo.TenantId,
		TenantName:             _cfg.Auth.Shieldoo.TenantId,
		MaxCertificateValidity: convertDateJson(model.SystemConfig().CA.ValidTo),
		IdentityImportEnabled:  model.SystemConfig().AADSyncConfig.Enabled,
	}
	return &ret, nil
}

// AdminDashboard is the resolver for the adminDashboard field.
func (r *queryResolver) AdminDashboard(ctx context.Context) (*gqlmodel.AdminDashboard, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	locUsers, locServers, locUsersInv, err := model.DacAdminDashboardStats()
	if err != nil {
		return nil, err
	}
	ret := gqlmodel.AdminDashboard{
		Users:        locUsers,
		Servers:      locServers,
		InvitedUsers: locUsersInv,
	}
	preloads := getPreloads(ctx)
	if contains(preloads, "userStatistics") {
		var userStas []model.StatUsersInHour
		userStas, err = model.DacAdminDashboardStatsUsersInHours()
		if err != nil {
			return nil, err
		}
		for _, u := range userStas {
			hour := 0
			if len(u.Date) > 8 {
				hour, _ = strconv.Atoi(u.Date[8:])
			}
			date := u.Date
			if len(date) > 8 {
				date = date[:8]
			}
			ret.UserStatistics = append(ret.UserStatistics, &gqlmodel.UserStatistic{
				Date:        date,
				Hour:        hour,
				UsersOnline: u.Users,
			})
		}
	}

	return &ret, nil
}

// CodelistGroups is the resolver for the codelistGroups field.
func (r *queryResolver) CodelistGroups(ctx context.Context) ([]*gqlmodel.CodeListItem, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	c, err := model.DacCodeListGroups()
	if err != nil {
		return nil, err
	}
	ret := modelconvCodeListItems2Gql(c)
	return ret, err
}

// CodelistFirewalls is the resolver for the codelistFirewalls field.
func (r *queryResolver) CodelistFirewalls(ctx context.Context) ([]*gqlmodel.CodeListItem, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	c, err := model.DacCodeListFirewalls()
	if err != nil {
		return nil, err
	}
	ret := modelconvCodeListItems2Gql(c)
	return ret, err
}

// CodelistUserAccessTemplates is the resolver for the codelistUserAccessTemplates field.
func (r *queryResolver) CodelistUserAccessTemplates(ctx context.Context) ([]*gqlmodel.CodeListItem, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	c, err := model.DacCodeListUserAccessTemplates()
	if err != nil {
		return nil, err
	}
	ret := modelconvCodeListItems2Gql(c)
	return ret, err
}

// TelemetryLogs is the resolver for the telemetryLogs field.
func (r *queryResolver) TelemetryLogs(ctx context.Context, filter *string, upn *string, createdFrom *string, createdTo *string) ([]*gqlmodel.LogItem, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	srch_upn := ""
	srch_filter := ""
	var srch_tfrom time.Time
	var srch_tto time.Time
	if upn != nil {
		srch_upn = *upn
	}
	if filter != nil {
		srch_filter = *filter
	}
	if createdFrom != nil {
		srch_tfrom = convertJsonDate2Date(*createdFrom)
	}
	if createdTo != nil {
		srch_tto = convertJsonDate2Date(*createdTo)
	}
	var dest []logstore.LogStore
	err := logstore.SearchLog(&dest, srch_upn, srch_tfrom, srch_tto, srch_filter, _cfg.Database.MaxRecords)
	var ret []*gqlmodel.LogItem
	if err == nil {
		for _, v := range dest {
			ret = append(ret, &gqlmodel.LogItem{ID: v.ID, Upn: v.UPN, Data: v.Data, Created: convertDateJson(v.Created)})
		}
	}
	return ret, err
}

// SecurityLogs is the resolver for the securityLogs field.
func (r *queryResolver) SecurityLogs(ctx context.Context, filter *string, upn *string, createdFrom *string, createdTo *string) ([]*gqlmodel.LogItem, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	srch_upn := ""
	srch_filter := ""
	var srch_tfrom time.Time
	var srch_tto time.Time
	if upn != nil {
		srch_upn = *upn
	}
	if filter != nil {
		srch_filter = *filter
	}
	if createdFrom != nil {
		srch_tfrom = convertJsonDate2Date(*createdFrom)
	}
	if createdTo != nil {
		srch_tto = convertJsonDate2Date(*createdTo)
	}
	var dest []logstore.LogStoreSecurity
	err := logstore.SearchSecLog(&dest, srch_upn, srch_tfrom, srch_tto, srch_filter, _cfg.Database.MaxRecords)
	var ret []*gqlmodel.LogItem
	if err == nil {
		for _, v := range dest {
			ret = append(ret, &gqlmodel.LogItem{ID: v.ID, Upn: v.UPN, Data: v.Data, Created: convertDateJson(v.Created)})
		}
	}
	return ret, err
}

// SystemConfig is the resolver for the systemConfig field.
func (r *queryResolver) SystemConfig(ctx context.Context) (*gqlmodel.SystemConfig, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	c := modelconvSystemConfig2Gql(*model.SystemConfig())
	return &c, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, name *string, origin *string) ([]*gqlmodel.User, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	log.Debug("gql query users")
	origin_filter := ""
	if origin != nil {
		origin_filter = *origin
	}
	filter := ""
	if name != nil {
		filter = *name
	}
	preloads := getPreloads(ctx)
	d, err := model.DacEntityList(
		model.ENTITY_USER,
		filter,
		origin_filter,
		false,
		contains(preloads, "userAccesses"))
	var m []*gqlmodel.User
	if err == nil {
		for _, i := range d {
			conv := modelconvEntityUser2Gql(i)
			m = append(m, &conv)
		}
	}
	return m, err
}

// Servers is the resolver for the servers field.
func (r *queryResolver) Servers(ctx context.Context, name *string) ([]*gqlmodel.Server, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	log.Debug("gql query servers")
	filter := ""
	if name != nil {
		filter = *name
	}
	preloads := getPreloads(ctx)
	preloadAccess := (contains(preloads, "access") || contains(preloads, "allowAutoUpdate") || contains(preloads, "serverOSAutoUpdatePolicy"))
	d, err := model.DacEntityList(
		model.ENTITY_SERVER,
		filter,
		"",
		preloadAccess,
		false)
	var m []*gqlmodel.Server
	if err == nil {
		for _, i := range d {
			conv := modelconvEntityServer2Gql(i)
			if preloadAccess {
				if len(i.Accesses) > 0 {
					a := modelconvAccess2Gql(i.Accesses[0])
					conv.Access = &a
					if i.Accesses[0].Autoupdate != nil {
						conv.AllowAutoUpdate = *i.Accesses[0].Autoupdate
					}
					updPolicy := modelconvOSAutoupdatePolicy2Gql(i.Accesses[0])
					conv.ServerOSAutoUpdatePolicy = &updPolicy
				} else {
					conv.Access = &gqlmodel.Access{}
					conv.ServerOSAutoUpdatePolicy = &gqlmodel.ServerOSAutoUpdatePolicy{}
				}
			}
			m = append(m, &conv)
		}
	}
	return m, err
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*gqlmodel.User, error) {
	if accerr := myjwt.JwtRoleCheckerContextUSER(ctx); accerr != nil {
		return nil, accerr
	}
	preloads := getPreloads(ctx)
	usr := myjwt.ClaimUserNameFromContext(ctx)
	d, err := model.DacEntityMe(usr)
	var e gqlmodel.User
	if err != nil {
		return &e, err
	}
	if err = model.DacEntityCheckLoginInfo(&d, myjwt.ClaimGetCustomFromContext(ctx), myjwt.ClaimGetRolesFromContext(ctx)); err != nil {
		return &e, err
	}
	e = modelconvEntityUser2Gql(d)
	log.Debug("gql ME: ", preloads)
	if contains(preloads, "userAccesses.serversForAccess") {
		allServers, err := model.DacAllServers()
		if err != nil {
			return &e, err
		}
		for _, v := range e.UserAccesses {
			v.ServersForAccess = resolveUserAccessToServerDependency(v, allServers)
		}
	}
	return &e, err
}

// Server is the resolver for the server field.
func (r *queryResolver) Server(ctx context.Context, id int) (*gqlmodel.Server, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	log.Debug("gql query entity")
	preloads := getPreloads(ctx)
	log.Debug("preloads: ", preloads)
	var d model.Entity
	var err error
	d, err = model.DacEntityAccesses(id)
	if d.EntityType != model.ENTITY_SERVER {
		return nil, errors.New("not a server")
	}
	var e gqlmodel.Server
	if err == nil {
		e = modelconvEntityServer2Gql(d)
	}
	return &e, err
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id int) (*gqlmodel.User, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	log.Debug("gql query entity")
	preloads := getPreloads(ctx)
	log.Debug("preloads: ", preloads)
	var d model.Entity
	var err error
	if contains(preloads, "userAccesses") || contains(preloads, "access") {
		d, err = model.DacEntityAccesses(id)
	} else {
		d, err = model.DacEntityGet(id)
	}
	if d.EntityType != model.ENTITY_USER {
		return nil, errors.New("not a user")
	}
	var e gqlmodel.User
	if err == nil {
		e = modelconvEntityUser2Gql(d)
	}
	return &e, err
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, id int) (*gqlmodel.Group, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	d, err := model.DacGroupGet(id)
	e := modelconvGroup2Gql(d)
	return &e, err
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context, name *string) ([]*gqlmodel.Group, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	filter := ""
	if name != nil {
		filter = *name
	}
	d, err := model.DacGroupList(filter)
	var m []*gqlmodel.Group
	if err == nil {
		for _, i := range d {
			conv := modelconvGroup2Gql(i)
			m = append(m, &conv)
		}
	}
	return m, err
}

// AccessListenerTypes is the resolver for the accessListenerTypes field.
func (r *queryResolver) AccessListenerTypes(ctx context.Context, name *string) ([]*gqlmodel.AccessListenerType, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	filter := ""
	if name != nil {
		filter = *name
	}
	d, err := model.DacAccessListenerTypeList(filter)
	var m []*gqlmodel.AccessListenerType
	if err == nil {
		for _, i := range d {
			conv := modelconvAccessListenerType2Gql(i)
			m = append(m, &conv)
		}
	}
	return m, err
}

// UserAccessTemplate is the resolver for the userAccessTemplate field.
func (r *queryResolver) UserAccessTemplate(ctx context.Context, id int) (*gqlmodel.UserAccessTemplate, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	d, err := model.DacUserAccessTemplateGet(id)
	e := modelconvUserAccessTemplate2Gql(d)
	return &e, err
}

// UserAccessTemplates is the resolver for the userAccessTemplates field.
func (r *queryResolver) UserAccessTemplates(ctx context.Context, name *string) ([]*gqlmodel.UserAccessTemplate, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	filter := ""
	if name != nil {
		filter = *name
	}
	d, err := model.DacUserAccessTemplateList(filter)
	var m []*gqlmodel.UserAccessTemplate
	if err == nil {
		for _, i := range d {
			conv := modelconvUserAccessTemplate2Gql(i)
			m = append(m, &conv)
		}
	}
	return m, err
}

// FirewallConfiguration is the resolver for the firewallConfiguration field.
func (r *queryResolver) FirewallConfiguration(ctx context.Context, id int) (*gqlmodel.FwConfig, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	d, err := model.DacFwconfigGet(id)
	e := modelconvFwConfig2Gql(d)
	return &e, err
}

// FirewallConfigurations is the resolver for the firewallConfigurations field.
func (r *queryResolver) FirewallConfigurations(ctx context.Context, name *string) ([]*gqlmodel.FwConfig, error) {
	if accerr := myjwt.JwtRoleCheckerContextADMINISTRATOR(ctx); accerr != nil {
		return nil, accerr
	}
	filter := ""
	if name != nil {
		filter = *name
	}
	d, err := model.DacFwconfigList(filter)
	var m []*gqlmodel.FwConfig
	if err == nil {
		for _, i := range d {
			conv := modelconvFwConfig2Gql(i)
			m = append(m, &conv)
		}
	}
	return m, err
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
const keyStoreKey = "AADTASK"
