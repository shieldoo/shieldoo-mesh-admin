// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlmodel "github.com/shieldoo/shieldoo-mesh-admin/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AadConfig struct {
		AdminGroupObjectID    func(childComplexity int) int
		ClientID              func(childComplexity int) int
		ClientSecret          func(childComplexity int) int
		IsEnabled             func(childComplexity int) int
		LastProcessingMessage func(childComplexity int) int
		TenantID              func(childComplexity int) int
	}

	Access struct {
		AdditionalHostnames func(childComplexity int) int
		Changed             func(childComplexity int) int
		Config              func(childComplexity int) int
		Description         func(childComplexity int) int
		DeviceInfo          func(childComplexity int) int
		Fqdn                func(childComplexity int) int
		FwConfig            func(childComplexity int) int
		Groups              func(childComplexity int) int
		ID                  func(childComplexity int) int
		IPAddress           func(childComplexity int) int
		Listeners           func(childComplexity int) int
		Name                func(childComplexity int) int
		PunchBack           func(childComplexity int) int
		RestrictiveNetwork  func(childComplexity int) int
		Statistics          func(childComplexity int) int
		ValidFrom           func(childComplexity int) int
		ValidTo             func(childComplexity int) int
	}

	AccessDevice struct {
		Contacted       func(childComplexity int) int
		DeviceID        func(childComplexity int) int
		DeviceOSType    func(childComplexity int) int
		DeviceOs        func(childComplexity int) int
		DeviceSWVersion func(childComplexity int) int
		Name            func(childComplexity int) int
		OsAutoUpdate    func(childComplexity int) int
	}

	AccessListener struct {
		AccessListenerType func(childComplexity int) int
		Description        func(childComplexity int) int
		ForwardHost        func(childComplexity int) int
		ForwardPort        func(childComplexity int) int
		ListenPort         func(childComplexity int) int
		Protocol           func(childComplexity int) int
	}

	AccessListenerType struct {
		Glyph func(childComplexity int) int
		ID    func(childComplexity int) int
		Name  func(childComplexity int) int
	}

	AccessStatistic struct {
		IsConnectd               func(childComplexity int) int
		IsOverRestrictiveNetwork func(childComplexity int) int
		LastContact              func(childComplexity int) int
		LastContactFromNow       func(childComplexity int) int
	}

	AdminDashboard struct {
		InvitedUsers   func(childComplexity int) int
		Servers        func(childComplexity int) int
		UserStatistics func(childComplexity int) int
		Users          func(childComplexity int) int
	}

	CliApiConfig struct {
		APIKey    func(childComplexity int) int
		IsEnabled func(childComplexity int) int
		URL       func(childComplexity int) int
	}

	CodeListItem struct {
		ID   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	ConfigItem struct {
		IdentityImportEnabled  func(childComplexity int) int
		MaxCertificateValidity func(childComplexity int) int
		MaxDBRecords           func(childComplexity int) int
		TenantID               func(childComplexity int) int
		TenantName             func(childComplexity int) int
	}

	CostUsageItem struct {
		Cost      func(childComplexity int) int
		Hours     func(childComplexity int) int
		IsUser    func(childComplexity int) int
		Upn       func(childComplexity int) int
		YearMonth func(childComplexity int) int
	}

	CostUsageMonthItem struct {
		Cost           func(childComplexity int) int
		CostUsageItems func(childComplexity int) int
		YearMonth      func(childComplexity int) int
	}

	FwConfig struct {
		Changed      func(childComplexity int) int
		FwConfigIns  func(childComplexity int) int
		FwConfigOuts func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
	}

	FwConfigRule struct {
		Groups func(childComplexity int) int
		Host   func(childComplexity int) int
		Port   func(childComplexity int) int
		Proto  func(childComplexity int) int
	}

	Group struct {
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	Lighthouse struct {
		IPAddress func(childComplexity int) int
		Port      func(childComplexity int) int
		PublicIP  func(childComplexity int) int
	}

	LogItem struct {
		Created func(childComplexity int) int
		Data    func(childComplexity int) int
		ID      func(childComplexity int) int
		Upn     func(childComplexity int) int
	}

	Mutation struct {
		FirewallConfigurationDelete func(childComplexity int, id int) int
		FirewallConfigurationSave   func(childComplexity int, data gqlmodel.FwConfigData) int
		GroupDelete                 func(childComplexity int, id int) int
		GroupSave                   func(childComplexity int, data gqlmodel.GroupData) int
		ServerDelete                func(childComplexity int, id int) int
		ServerSave                  func(childComplexity int, data *gqlmodel.ServerData) int
		SystemAadConfigSave         func(childComplexity int, data gqlmodel.AadConfigData) int
		SystemCliAPIConfigSave      func(childComplexity int, data gqlmodel.CliAPIConfigData) int
		SystemConfigSave            func(childComplexity int, data gqlmodel.SystemConfigData) int
		UserAccessDelete            func(childComplexity int, id int) int
		UserAccessSave              func(childComplexity int, data gqlmodel.UserAccessData) int
		UserAccessTemplateDelete    func(childComplexity int, id int) int
		UserAccessTemplateSave      func(childComplexity int, data gqlmodel.UserAccessTemplateData) int
		UserDelete                  func(childComplexity int, id int) int
		UserDeviceCreate            func(childComplexity int, userAccessID int, data gqlmodel.AccessDeviceData, publicKey *string) int
		UserDeviceDelete            func(childComplexity int, id int) int
		UserDeviceSaveNote          func(childComplexity int, id int, note string) int
		UserInvite                  func(childComplexity int, data gqlmodel.InviteUserData) int
		UserSave                    func(childComplexity int, data gqlmodel.UserData) int
	}

	OsAutoUpdate struct {
		Description          func(childComplexity int) int
		LastUpdate           func(childComplexity int) int
		LastUpdateOutput     func(childComplexity int) int
		LastUpdateSuccess    func(childComplexity int) int
		Name                 func(childComplexity int) int
		OsType               func(childComplexity int) int
		OtherUpdates         func(childComplexity int) int
		OtherUpdatesCount    func(childComplexity int) int
		SecurityUpdates      func(childComplexity int) int
		SecurityUpdatesCount func(childComplexity int) int
		Version              func(childComplexity int) int
	}

	Query struct {
		AccessListenerTypes         func(childComplexity int, name *string) int
		AdminDashboard              func(childComplexity int) int
		CodelistFirewalls           func(childComplexity int) int
		CodelistGroups              func(childComplexity int) int
		CodelistUserAccessTemplates func(childComplexity int) int
		Config                      func(childComplexity int) int
		FirewallConfiguration       func(childComplexity int, id int) int
		FirewallConfigurations      func(childComplexity int, name *string) int
		Group                       func(childComplexity int, id int) int
		Groups                      func(childComplexity int, name *string) int
		Me                          func(childComplexity int) int
		MonthCostUsage              func(childComplexity int) int
		SecurityLogs                func(childComplexity int, filter *string, upn *string, createdFrom *string, createdTo *string) int
		Server                      func(childComplexity int, id int) int
		Servers                     func(childComplexity int, name *string) int
		SystemConfig                func(childComplexity int) int
		TelemetryLogs               func(childComplexity int, filter *string, upn *string, createdFrom *string, createdTo *string) int
		User                        func(childComplexity int, id int) int
		UserAccessTemplate          func(childComplexity int, id int) int
		UserAccessTemplates         func(childComplexity int, name *string) int
		Users                       func(childComplexity int, name *string, origin *string) int
	}

	Server struct {
		Access                   func(childComplexity int) int
		AllowAutoUpdate          func(childComplexity int) int
		Description              func(childComplexity int) int
		ID                       func(childComplexity int) int
		Name                     func(childComplexity int) int
		ServerOSAutoUpdatePolicy func(childComplexity int) int
	}

	ServerForAccess struct {
		Description func(childComplexity int) int
		IPAddress   func(childComplexity int) int
		Listeners   func(childComplexity int) int
		Name        func(childComplexity int) int
		Statistics  func(childComplexity int) int
	}

	ServerOSAutoUpdatePolicy struct {
		AllAutoUpdateEnabled      func(childComplexity int) int
		OsAutoUpdateEnabled       func(childComplexity int) int
		OsAutoUpdateHour          func(childComplexity int) int
		RestartAfterUpdate        func(childComplexity int) int
		SecurityAutoUpdateEnabled func(childComplexity int) int
	}

	SystemConfig struct {
		AadConfig                  func(childComplexity int) int
		CliAPIConfig               func(childComplexity int) int
		Lighthouses                func(childComplexity int) int
		MaximumCertificateValidity func(childComplexity int) int
		NetworkCidr                func(childComplexity int) int
	}

	User struct {
		Description  func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		Origin       func(childComplexity int) int
		Roles        func(childComplexity int) int
		Upn          func(childComplexity int) int
		UserAccesses func(childComplexity int) int
	}

	UserAccess struct {
		Accesses           func(childComplexity int) int
		Changed            func(childComplexity int) int
		Description        func(childComplexity int) int
		FwConfig           func(childComplexity int) int
		Groups             func(childComplexity int) int
		ID                 func(childComplexity int) int
		Name               func(childComplexity int) int
		ServersForAccess   func(childComplexity int) int
		UserAccessTemplate func(childComplexity int) int
		ValidFrom          func(childComplexity int) int
		ValidTo            func(childComplexity int) int
	}

	UserAccessDeviceInfo struct {
		Access              func(childComplexity int) int
		CaPublicKey         func(childComplexity int) int
		Certificate         func(childComplexity int) int
		LighthouseIP        func(childComplexity int) int
		LighthousePort      func(childComplexity int) int
		LighthousePrivateIP func(childComplexity int) int
	}

	UserAccessTemplate struct {
		Changed     func(childComplexity int) int
		Description func(childComplexity int) int
		FwConfig    func(childComplexity int) int
		Groups      func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		ValidFrom   func(childComplexity int) int
		ValidTo     func(childComplexity int) int
	}

	UserStatistic struct {
		Date        func(childComplexity int) int
		Hour        func(childComplexity int) int
		UsersOnline func(childComplexity int) int
	}
}

type MutationResolver interface {
	SystemConfigSave(ctx context.Context, data gqlmodel.SystemConfigData) (*gqlmodel.SystemConfig, error)
	SystemAadConfigSave(ctx context.Context, data gqlmodel.AadConfigData) (*gqlmodel.AadConfig, error)
	SystemCliAPIConfigSave(ctx context.Context, data gqlmodel.CliAPIConfigData) (*gqlmodel.CliAPIConfig, error)
	UserInvite(ctx context.Context, data gqlmodel.InviteUserData) (*gqlmodel.User, error)
	ServerDelete(ctx context.Context, id int) (*gqlmodel.Server, error)
	UserDelete(ctx context.Context, id int) (*gqlmodel.User, error)
	ServerSave(ctx context.Context, data *gqlmodel.ServerData) (*gqlmodel.Server, error)
	UserSave(ctx context.Context, data gqlmodel.UserData) (*gqlmodel.User, error)
	GroupDelete(ctx context.Context, id int) (*gqlmodel.Group, error)
	GroupSave(ctx context.Context, data gqlmodel.GroupData) (*gqlmodel.Group, error)
	UserAccessTemplateDelete(ctx context.Context, id int) (*gqlmodel.UserAccessTemplate, error)
	UserAccessTemplateSave(ctx context.Context, data gqlmodel.UserAccessTemplateData) (*gqlmodel.UserAccessTemplate, error)
	FirewallConfigurationDelete(ctx context.Context, id int) (*gqlmodel.FwConfig, error)
	FirewallConfigurationSave(ctx context.Context, data gqlmodel.FwConfigData) (*gqlmodel.FwConfig, error)
	UserAccessDelete(ctx context.Context, id int) (*gqlmodel.UserAccess, error)
	UserAccessSave(ctx context.Context, data gqlmodel.UserAccessData) (*gqlmodel.UserAccess, error)
	UserDeviceSaveNote(ctx context.Context, id int, note string) (*gqlmodel.Access, error)
	UserDeviceDelete(ctx context.Context, id int) (int, error)
	UserDeviceCreate(ctx context.Context, userAccessID int, data gqlmodel.AccessDeviceData, publicKey *string) (*gqlmodel.UserAccessDeviceInfo, error)
}
type QueryResolver interface {
	MonthCostUsage(ctx context.Context) ([]*gqlmodel.CostUsageMonthItem, error)
	Config(ctx context.Context) (*gqlmodel.ConfigItem, error)
	AdminDashboard(ctx context.Context) (*gqlmodel.AdminDashboard, error)
	CodelistGroups(ctx context.Context) ([]*gqlmodel.CodeListItem, error)
	CodelistFirewalls(ctx context.Context) ([]*gqlmodel.CodeListItem, error)
	CodelistUserAccessTemplates(ctx context.Context) ([]*gqlmodel.CodeListItem, error)
	TelemetryLogs(ctx context.Context, filter *string, upn *string, createdFrom *string, createdTo *string) ([]*gqlmodel.LogItem, error)
	SecurityLogs(ctx context.Context, filter *string, upn *string, createdFrom *string, createdTo *string) ([]*gqlmodel.LogItem, error)
	SystemConfig(ctx context.Context) (*gqlmodel.SystemConfig, error)
	Users(ctx context.Context, name *string, origin *string) ([]*gqlmodel.User, error)
	Servers(ctx context.Context, name *string) ([]*gqlmodel.Server, error)
	Me(ctx context.Context) (*gqlmodel.User, error)
	Server(ctx context.Context, id int) (*gqlmodel.Server, error)
	User(ctx context.Context, id int) (*gqlmodel.User, error)
	Group(ctx context.Context, id int) (*gqlmodel.Group, error)
	Groups(ctx context.Context, name *string) ([]*gqlmodel.Group, error)
	AccessListenerTypes(ctx context.Context, name *string) ([]*gqlmodel.AccessListenerType, error)
	UserAccessTemplate(ctx context.Context, id int) (*gqlmodel.UserAccessTemplate, error)
	UserAccessTemplates(ctx context.Context, name *string) ([]*gqlmodel.UserAccessTemplate, error)
	FirewallConfiguration(ctx context.Context, id int) (*gqlmodel.FwConfig, error)
	FirewallConfigurations(ctx context.Context, name *string) ([]*gqlmodel.FwConfig, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AadConfig.adminGroupObjectId":
		if e.complexity.AadConfig.AdminGroupObjectID == nil {
			break
		}

		return e.complexity.AadConfig.AdminGroupObjectID(childComplexity), true

	case "AadConfig.clientId":
		if e.complexity.AadConfig.ClientID == nil {
			break
		}

		return e.complexity.AadConfig.ClientID(childComplexity), true

	case "AadConfig.clientSecret":
		if e.complexity.AadConfig.ClientSecret == nil {
			break
		}

		return e.complexity.AadConfig.ClientSecret(childComplexity), true

	case "AadConfig.isEnabled":
		if e.complexity.AadConfig.IsEnabled == nil {
			break
		}

		return e.complexity.AadConfig.IsEnabled(childComplexity), true

	case "AadConfig.lastProcessingMessage":
		if e.complexity.AadConfig.LastProcessingMessage == nil {
			break
		}

		return e.complexity.AadConfig.LastProcessingMessage(childComplexity), true

	case "AadConfig.tenantId":
		if e.complexity.AadConfig.TenantID == nil {
			break
		}

		return e.complexity.AadConfig.TenantID(childComplexity), true

	case "Access.additionalHostnames":
		if e.complexity.Access.AdditionalHostnames == nil {
			break
		}

		return e.complexity.Access.AdditionalHostnames(childComplexity), true

	case "Access.changed":
		if e.complexity.Access.Changed == nil {
			break
		}

		return e.complexity.Access.Changed(childComplexity), true

	case "Access.config":
		if e.complexity.Access.Config == nil {
			break
		}

		return e.complexity.Access.Config(childComplexity), true

	case "Access.description":
		if e.complexity.Access.Description == nil {
			break
		}

		return e.complexity.Access.Description(childComplexity), true

	case "Access.deviceInfo":
		if e.complexity.Access.DeviceInfo == nil {
			break
		}

		return e.complexity.Access.DeviceInfo(childComplexity), true

	case "Access.fqdn":
		if e.complexity.Access.Fqdn == nil {
			break
		}

		return e.complexity.Access.Fqdn(childComplexity), true

	case "Access.fwConfig":
		if e.complexity.Access.FwConfig == nil {
			break
		}

		return e.complexity.Access.FwConfig(childComplexity), true

	case "Access.groups":
		if e.complexity.Access.Groups == nil {
			break
		}

		return e.complexity.Access.Groups(childComplexity), true

	case "Access.id":
		if e.complexity.Access.ID == nil {
			break
		}

		return e.complexity.Access.ID(childComplexity), true

	case "Access.ipAddress":
		if e.complexity.Access.IPAddress == nil {
			break
		}

		return e.complexity.Access.IPAddress(childComplexity), true

	case "Access.listeners":
		if e.complexity.Access.Listeners == nil {
			break
		}

		return e.complexity.Access.Listeners(childComplexity), true

	case "Access.name":
		if e.complexity.Access.Name == nil {
			break
		}

		return e.complexity.Access.Name(childComplexity), true

	case "Access.punchBack":
		if e.complexity.Access.PunchBack == nil {
			break
		}

		return e.complexity.Access.PunchBack(childComplexity), true

	case "Access.restrictiveNetwork":
		if e.complexity.Access.RestrictiveNetwork == nil {
			break
		}

		return e.complexity.Access.RestrictiveNetwork(childComplexity), true

	case "Access.statistics":
		if e.complexity.Access.Statistics == nil {
			break
		}

		return e.complexity.Access.Statistics(childComplexity), true

	case "Access.validFrom":
		if e.complexity.Access.ValidFrom == nil {
			break
		}

		return e.complexity.Access.ValidFrom(childComplexity), true

	case "Access.validTo":
		if e.complexity.Access.ValidTo == nil {
			break
		}

		return e.complexity.Access.ValidTo(childComplexity), true

	case "AccessDevice.contacted":
		if e.complexity.AccessDevice.Contacted == nil {
			break
		}

		return e.complexity.AccessDevice.Contacted(childComplexity), true

	case "AccessDevice.deviceId":
		if e.complexity.AccessDevice.DeviceID == nil {
			break
		}

		return e.complexity.AccessDevice.DeviceID(childComplexity), true

	case "AccessDevice.deviceOSType":
		if e.complexity.AccessDevice.DeviceOSType == nil {
			break
		}

		return e.complexity.AccessDevice.DeviceOSType(childComplexity), true

	case "AccessDevice.deviceOS":
		if e.complexity.AccessDevice.DeviceOs == nil {
			break
		}

		return e.complexity.AccessDevice.DeviceOs(childComplexity), true

	case "AccessDevice.deviceSWVersion":
		if e.complexity.AccessDevice.DeviceSWVersion == nil {
			break
		}

		return e.complexity.AccessDevice.DeviceSWVersion(childComplexity), true

	case "AccessDevice.name":
		if e.complexity.AccessDevice.Name == nil {
			break
		}

		return e.complexity.AccessDevice.Name(childComplexity), true

	case "AccessDevice.osAutoUpdate":
		if e.complexity.AccessDevice.OsAutoUpdate == nil {
			break
		}

		return e.complexity.AccessDevice.OsAutoUpdate(childComplexity), true

	case "AccessListener.accessListenerType":
		if e.complexity.AccessListener.AccessListenerType == nil {
			break
		}

		return e.complexity.AccessListener.AccessListenerType(childComplexity), true

	case "AccessListener.description":
		if e.complexity.AccessListener.Description == nil {
			break
		}

		return e.complexity.AccessListener.Description(childComplexity), true

	case "AccessListener.forwardHost":
		if e.complexity.AccessListener.ForwardHost == nil {
			break
		}

		return e.complexity.AccessListener.ForwardHost(childComplexity), true

	case "AccessListener.forwardPort":
		if e.complexity.AccessListener.ForwardPort == nil {
			break
		}

		return e.complexity.AccessListener.ForwardPort(childComplexity), true

	case "AccessListener.listenPort":
		if e.complexity.AccessListener.ListenPort == nil {
			break
		}

		return e.complexity.AccessListener.ListenPort(childComplexity), true

	case "AccessListener.protocol":
		if e.complexity.AccessListener.Protocol == nil {
			break
		}

		return e.complexity.AccessListener.Protocol(childComplexity), true

	case "AccessListenerType.glyph":
		if e.complexity.AccessListenerType.Glyph == nil {
			break
		}

		return e.complexity.AccessListenerType.Glyph(childComplexity), true

	case "AccessListenerType.id":
		if e.complexity.AccessListenerType.ID == nil {
			break
		}

		return e.complexity.AccessListenerType.ID(childComplexity), true

	case "AccessListenerType.name":
		if e.complexity.AccessListenerType.Name == nil {
			break
		}

		return e.complexity.AccessListenerType.Name(childComplexity), true

	case "AccessStatistic.isConnectd":
		if e.complexity.AccessStatistic.IsConnectd == nil {
			break
		}

		return e.complexity.AccessStatistic.IsConnectd(childComplexity), true

	case "AccessStatistic.isOverRestrictiveNetwork":
		if e.complexity.AccessStatistic.IsOverRestrictiveNetwork == nil {
			break
		}

		return e.complexity.AccessStatistic.IsOverRestrictiveNetwork(childComplexity), true

	case "AccessStatistic.lastContact":
		if e.complexity.AccessStatistic.LastContact == nil {
			break
		}

		return e.complexity.AccessStatistic.LastContact(childComplexity), true

	case "AccessStatistic.lastContactFromNow":
		if e.complexity.AccessStatistic.LastContactFromNow == nil {
			break
		}

		return e.complexity.AccessStatistic.LastContactFromNow(childComplexity), true

	case "AdminDashboard.invitedUsers":
		if e.complexity.AdminDashboard.InvitedUsers == nil {
			break
		}

		return e.complexity.AdminDashboard.InvitedUsers(childComplexity), true

	case "AdminDashboard.servers":
		if e.complexity.AdminDashboard.Servers == nil {
			break
		}

		return e.complexity.AdminDashboard.Servers(childComplexity), true

	case "AdminDashboard.userStatistics":
		if e.complexity.AdminDashboard.UserStatistics == nil {
			break
		}

		return e.complexity.AdminDashboard.UserStatistics(childComplexity), true

	case "AdminDashboard.users":
		if e.complexity.AdminDashboard.Users == nil {
			break
		}

		return e.complexity.AdminDashboard.Users(childComplexity), true

	case "CliApiConfig.apiKey":
		if e.complexity.CliApiConfig.APIKey == nil {
			break
		}

		return e.complexity.CliApiConfig.APIKey(childComplexity), true

	case "CliApiConfig.isEnabled":
		if e.complexity.CliApiConfig.IsEnabled == nil {
			break
		}

		return e.complexity.CliApiConfig.IsEnabled(childComplexity), true

	case "CliApiConfig.url":
		if e.complexity.CliApiConfig.URL == nil {
			break
		}

		return e.complexity.CliApiConfig.URL(childComplexity), true

	case "CodeListItem.id":
		if e.complexity.CodeListItem.ID == nil {
			break
		}

		return e.complexity.CodeListItem.ID(childComplexity), true

	case "CodeListItem.name":
		if e.complexity.CodeListItem.Name == nil {
			break
		}

		return e.complexity.CodeListItem.Name(childComplexity), true

	case "ConfigItem.identityImportEnabled":
		if e.complexity.ConfigItem.IdentityImportEnabled == nil {
			break
		}

		return e.complexity.ConfigItem.IdentityImportEnabled(childComplexity), true

	case "ConfigItem.maxCertificateValidity":
		if e.complexity.ConfigItem.MaxCertificateValidity == nil {
			break
		}

		return e.complexity.ConfigItem.MaxCertificateValidity(childComplexity), true

	case "ConfigItem.maxDBRecords":
		if e.complexity.ConfigItem.MaxDBRecords == nil {
			break
		}

		return e.complexity.ConfigItem.MaxDBRecords(childComplexity), true

	case "ConfigItem.tenantId":
		if e.complexity.ConfigItem.TenantID == nil {
			break
		}

		return e.complexity.ConfigItem.TenantID(childComplexity), true

	case "ConfigItem.tenantName":
		if e.complexity.ConfigItem.TenantName == nil {
			break
		}

		return e.complexity.ConfigItem.TenantName(childComplexity), true

	case "CostUsageItem.cost":
		if e.complexity.CostUsageItem.Cost == nil {
			break
		}

		return e.complexity.CostUsageItem.Cost(childComplexity), true

	case "CostUsageItem.hours":
		if e.complexity.CostUsageItem.Hours == nil {
			break
		}

		return e.complexity.CostUsageItem.Hours(childComplexity), true

	case "CostUsageItem.isUser":
		if e.complexity.CostUsageItem.IsUser == nil {
			break
		}

		return e.complexity.CostUsageItem.IsUser(childComplexity), true

	case "CostUsageItem.upn":
		if e.complexity.CostUsageItem.Upn == nil {
			break
		}

		return e.complexity.CostUsageItem.Upn(childComplexity), true

	case "CostUsageItem.yearMonth":
		if e.complexity.CostUsageItem.YearMonth == nil {
			break
		}

		return e.complexity.CostUsageItem.YearMonth(childComplexity), true

	case "CostUsageMonthItem.cost":
		if e.complexity.CostUsageMonthItem.Cost == nil {
			break
		}

		return e.complexity.CostUsageMonthItem.Cost(childComplexity), true

	case "CostUsageMonthItem.costUsageItems":
		if e.complexity.CostUsageMonthItem.CostUsageItems == nil {
			break
		}

		return e.complexity.CostUsageMonthItem.CostUsageItems(childComplexity), true

	case "CostUsageMonthItem.yearMonth":
		if e.complexity.CostUsageMonthItem.YearMonth == nil {
			break
		}

		return e.complexity.CostUsageMonthItem.YearMonth(childComplexity), true

	case "FwConfig.changed":
		if e.complexity.FwConfig.Changed == nil {
			break
		}

		return e.complexity.FwConfig.Changed(childComplexity), true

	case "FwConfig.fwConfigIns":
		if e.complexity.FwConfig.FwConfigIns == nil {
			break
		}

		return e.complexity.FwConfig.FwConfigIns(childComplexity), true

	case "FwConfig.fwConfigOuts":
		if e.complexity.FwConfig.FwConfigOuts == nil {
			break
		}

		return e.complexity.FwConfig.FwConfigOuts(childComplexity), true

	case "FwConfig.id":
		if e.complexity.FwConfig.ID == nil {
			break
		}

		return e.complexity.FwConfig.ID(childComplexity), true

	case "FwConfig.name":
		if e.complexity.FwConfig.Name == nil {
			break
		}

		return e.complexity.FwConfig.Name(childComplexity), true

	case "FwConfigRule.groups":
		if e.complexity.FwConfigRule.Groups == nil {
			break
		}

		return e.complexity.FwConfigRule.Groups(childComplexity), true

	case "FwConfigRule.host":
		if e.complexity.FwConfigRule.Host == nil {
			break
		}

		return e.complexity.FwConfigRule.Host(childComplexity), true

	case "FwConfigRule.port":
		if e.complexity.FwConfigRule.Port == nil {
			break
		}

		return e.complexity.FwConfigRule.Port(childComplexity), true

	case "FwConfigRule.proto":
		if e.complexity.FwConfigRule.Proto == nil {
			break
		}

		return e.complexity.FwConfigRule.Proto(childComplexity), true

	case "Group.description":
		if e.complexity.Group.Description == nil {
			break
		}

		return e.complexity.Group.Description(childComplexity), true

	case "Group.id":
		if e.complexity.Group.ID == nil {
			break
		}

		return e.complexity.Group.ID(childComplexity), true

	case "Group.name":
		if e.complexity.Group.Name == nil {
			break
		}

		return e.complexity.Group.Name(childComplexity), true

	case "Lighthouse.ipAddress":
		if e.complexity.Lighthouse.IPAddress == nil {
			break
		}

		return e.complexity.Lighthouse.IPAddress(childComplexity), true

	case "Lighthouse.port":
		if e.complexity.Lighthouse.Port == nil {
			break
		}

		return e.complexity.Lighthouse.Port(childComplexity), true

	case "Lighthouse.publicIp":
		if e.complexity.Lighthouse.PublicIP == nil {
			break
		}

		return e.complexity.Lighthouse.PublicIP(childComplexity), true

	case "LogItem.created":
		if e.complexity.LogItem.Created == nil {
			break
		}

		return e.complexity.LogItem.Created(childComplexity), true

	case "LogItem.data":
		if e.complexity.LogItem.Data == nil {
			break
		}

		return e.complexity.LogItem.Data(childComplexity), true

	case "LogItem.id":
		if e.complexity.LogItem.ID == nil {
			break
		}

		return e.complexity.LogItem.ID(childComplexity), true

	case "LogItem.upn":
		if e.complexity.LogItem.Upn == nil {
			break
		}

		return e.complexity.LogItem.Upn(childComplexity), true

	case "Mutation.firewallConfigurationDelete":
		if e.complexity.Mutation.FirewallConfigurationDelete == nil {
			break
		}

		args, err := ec.field_Mutation_firewallConfigurationDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FirewallConfigurationDelete(childComplexity, args["id"].(int)), true

	case "Mutation.firewallConfigurationSave":
		if e.complexity.Mutation.FirewallConfigurationSave == nil {
			break
		}

		args, err := ec.field_Mutation_firewallConfigurationSave_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FirewallConfigurationSave(childComplexity, args["data"].(gqlmodel.FwConfigData)), true

	case "Mutation.groupDelete":
		if e.complexity.Mutation.GroupDelete == nil {
			break
		}

		args, err := ec.field_Mutation_groupDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GroupDelete(childComplexity, args["id"].(int)), true

	case "Mutation.groupSave":
		if e.complexity.Mutation.GroupSave == nil {
			break
		}

		args, err := ec.field_Mutation_groupSave_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GroupSave(childComplexity, args["data"].(gqlmodel.GroupData)), true

	case "Mutation.serverDelete":
		if e.complexity.Mutation.ServerDelete == nil {
			break
		}

		args, err := ec.field_Mutation_serverDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ServerDelete(childComplexity, args["id"].(int)), true

	case "Mutation.serverSave":
		if e.complexity.Mutation.ServerSave == nil {
			break
		}

		args, err := ec.field_Mutation_serverSave_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ServerSave(childComplexity, args["data"].(*gqlmodel.ServerData)), true

	case "Mutation.systemAadConfigSave":
		if e.complexity.Mutation.SystemAadConfigSave == nil {
			break
		}

		args, err := ec.field_Mutation_systemAadConfigSave_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SystemAadConfigSave(childComplexity, args["data"].(gqlmodel.AadConfigData)), true

	case "Mutation.systemCliApiConfigSave":
		if e.complexity.Mutation.SystemCliAPIConfigSave == nil {
			break
		}

		args, err := ec.field_Mutation_systemCliApiConfigSave_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SystemCliAPIConfigSave(childComplexity, args["data"].(gqlmodel.CliAPIConfigData)), true

	case "Mutation.systemConfigSave":
		if e.complexity.Mutation.SystemConfigSave == nil {
			break
		}

		args, err := ec.field_Mutation_systemConfigSave_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SystemConfigSave(childComplexity, args["data"].(gqlmodel.SystemConfigData)), true

	case "Mutation.userAccessDelete":
		if e.complexity.Mutation.UserAccessDelete == nil {
			break
		}

		args, err := ec.field_Mutation_userAccessDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserAccessDelete(childComplexity, args["id"].(int)), true

	case "Mutation.userAccessSave":
		if e.complexity.Mutation.UserAccessSave == nil {
			break
		}

		args, err := ec.field_Mutation_userAccessSave_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserAccessSave(childComplexity, args["data"].(gqlmodel.UserAccessData)), true

	case "Mutation.userAccessTemplateDelete":
		if e.complexity.Mutation.UserAccessTemplateDelete == nil {
			break
		}

		args, err := ec.field_Mutation_userAccessTemplateDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserAccessTemplateDelete(childComplexity, args["id"].(int)), true

	case "Mutation.userAccessTemplateSave":
		if e.complexity.Mutation.UserAccessTemplateSave == nil {
			break
		}

		args, err := ec.field_Mutation_userAccessTemplateSave_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserAccessTemplateSave(childComplexity, args["data"].(gqlmodel.UserAccessTemplateData)), true

	case "Mutation.userDelete":
		if e.complexity.Mutation.UserDelete == nil {
			break
		}

		args, err := ec.field_Mutation_userDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserDelete(childComplexity, args["id"].(int)), true

	case "Mutation.userDeviceCreate":
		if e.complexity.Mutation.UserDeviceCreate == nil {
			break
		}

		args, err := ec.field_Mutation_userDeviceCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserDeviceCreate(childComplexity, args["userAccessId"].(int), args["data"].(gqlmodel.AccessDeviceData), args["publicKey"].(*string)), true

	case "Mutation.userDeviceDelete":
		if e.complexity.Mutation.UserDeviceDelete == nil {
			break
		}

		args, err := ec.field_Mutation_userDeviceDelete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserDeviceDelete(childComplexity, args["id"].(int)), true

	case "Mutation.userDeviceSaveNote":
		if e.complexity.Mutation.UserDeviceSaveNote == nil {
			break
		}

		args, err := ec.field_Mutation_userDeviceSaveNote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserDeviceSaveNote(childComplexity, args["id"].(int), args["note"].(string)), true

	case "Mutation.userInvite":
		if e.complexity.Mutation.UserInvite == nil {
			break
		}

		args, err := ec.field_Mutation_userInvite_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserInvite(childComplexity, args["data"].(gqlmodel.InviteUserData)), true

	case "Mutation.userSave":
		if e.complexity.Mutation.UserSave == nil {
			break
		}

		args, err := ec.field_Mutation_userSave_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UserSave(childComplexity, args["data"].(gqlmodel.UserData)), true

	case "OsAutoUpdate.description":
		if e.complexity.OsAutoUpdate.Description == nil {
			break
		}

		return e.complexity.OsAutoUpdate.Description(childComplexity), true

	case "OsAutoUpdate.lastUpdate":
		if e.complexity.OsAutoUpdate.LastUpdate == nil {
			break
		}

		return e.complexity.OsAutoUpdate.LastUpdate(childComplexity), true

	case "OsAutoUpdate.lastUpdateOutput":
		if e.complexity.OsAutoUpdate.LastUpdateOutput == nil {
			break
		}

		return e.complexity.OsAutoUpdate.LastUpdateOutput(childComplexity), true

	case "OsAutoUpdate.lastUpdateSuccess":
		if e.complexity.OsAutoUpdate.LastUpdateSuccess == nil {
			break
		}

		return e.complexity.OsAutoUpdate.LastUpdateSuccess(childComplexity), true

	case "OsAutoUpdate.name":
		if e.complexity.OsAutoUpdate.Name == nil {
			break
		}

		return e.complexity.OsAutoUpdate.Name(childComplexity), true

	case "OsAutoUpdate.osType":
		if e.complexity.OsAutoUpdate.OsType == nil {
			break
		}

		return e.complexity.OsAutoUpdate.OsType(childComplexity), true

	case "OsAutoUpdate.otherUpdates":
		if e.complexity.OsAutoUpdate.OtherUpdates == nil {
			break
		}

		return e.complexity.OsAutoUpdate.OtherUpdates(childComplexity), true

	case "OsAutoUpdate.otherUpdatesCount":
		if e.complexity.OsAutoUpdate.OtherUpdatesCount == nil {
			break
		}

		return e.complexity.OsAutoUpdate.OtherUpdatesCount(childComplexity), true

	case "OsAutoUpdate.securityUpdates":
		if e.complexity.OsAutoUpdate.SecurityUpdates == nil {
			break
		}

		return e.complexity.OsAutoUpdate.SecurityUpdates(childComplexity), true

	case "OsAutoUpdate.securityUpdatesCount":
		if e.complexity.OsAutoUpdate.SecurityUpdatesCount == nil {
			break
		}

		return e.complexity.OsAutoUpdate.SecurityUpdatesCount(childComplexity), true

	case "OsAutoUpdate.version":
		if e.complexity.OsAutoUpdate.Version == nil {
			break
		}

		return e.complexity.OsAutoUpdate.Version(childComplexity), true

	case "Query.accessListenerTypes":
		if e.complexity.Query.AccessListenerTypes == nil {
			break
		}

		args, err := ec.field_Query_accessListenerTypes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AccessListenerTypes(childComplexity, args["name"].(*string)), true

	case "Query.adminDashboard":
		if e.complexity.Query.AdminDashboard == nil {
			break
		}

		return e.complexity.Query.AdminDashboard(childComplexity), true

	case "Query.codelistFirewalls":
		if e.complexity.Query.CodelistFirewalls == nil {
			break
		}

		return e.complexity.Query.CodelistFirewalls(childComplexity), true

	case "Query.codelistGroups":
		if e.complexity.Query.CodelistGroups == nil {
			break
		}

		return e.complexity.Query.CodelistGroups(childComplexity), true

	case "Query.codelistUserAccessTemplates":
		if e.complexity.Query.CodelistUserAccessTemplates == nil {
			break
		}

		return e.complexity.Query.CodelistUserAccessTemplates(childComplexity), true

	case "Query.config":
		if e.complexity.Query.Config == nil {
			break
		}

		return e.complexity.Query.Config(childComplexity), true

	case "Query.firewallConfiguration":
		if e.complexity.Query.FirewallConfiguration == nil {
			break
		}

		args, err := ec.field_Query_firewallConfiguration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FirewallConfiguration(childComplexity, args["id"].(int)), true

	case "Query.firewallConfigurations":
		if e.complexity.Query.FirewallConfigurations == nil {
			break
		}

		args, err := ec.field_Query_firewallConfigurations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FirewallConfigurations(childComplexity, args["name"].(*string)), true

	case "Query.group":
		if e.complexity.Query.Group == nil {
			break
		}

		args, err := ec.field_Query_group_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Group(childComplexity, args["id"].(int)), true

	case "Query.groups":
		if e.complexity.Query.Groups == nil {
			break
		}

		args, err := ec.field_Query_groups_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Groups(childComplexity, args["name"].(*string)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.monthCostUsage":
		if e.complexity.Query.MonthCostUsage == nil {
			break
		}

		return e.complexity.Query.MonthCostUsage(childComplexity), true

	case "Query.securityLogs":
		if e.complexity.Query.SecurityLogs == nil {
			break
		}

		args, err := ec.field_Query_securityLogs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SecurityLogs(childComplexity, args["filter"].(*string), args["upn"].(*string), args["createdFrom"].(*string), args["createdTo"].(*string)), true

	case "Query.server":
		if e.complexity.Query.Server == nil {
			break
		}

		args, err := ec.field_Query_server_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Server(childComplexity, args["id"].(int)), true

	case "Query.servers":
		if e.complexity.Query.Servers == nil {
			break
		}

		args, err := ec.field_Query_servers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Servers(childComplexity, args["name"].(*string)), true

	case "Query.systemConfig":
		if e.complexity.Query.SystemConfig == nil {
			break
		}

		return e.complexity.Query.SystemConfig(childComplexity), true

	case "Query.telemetryLogs":
		if e.complexity.Query.TelemetryLogs == nil {
			break
		}

		args, err := ec.field_Query_telemetryLogs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TelemetryLogs(childComplexity, args["filter"].(*string), args["upn"].(*string), args["createdFrom"].(*string), args["createdTo"].(*string)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(int)), true

	case "Query.userAccessTemplate":
		if e.complexity.Query.UserAccessTemplate == nil {
			break
		}

		args, err := ec.field_Query_userAccessTemplate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserAccessTemplate(childComplexity, args["id"].(int)), true

	case "Query.userAccessTemplates":
		if e.complexity.Query.UserAccessTemplates == nil {
			break
		}

		args, err := ec.field_Query_userAccessTemplates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserAccessTemplates(childComplexity, args["name"].(*string)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["name"].(*string), args["origin"].(*string)), true

	case "Server.access":
		if e.complexity.Server.Access == nil {
			break
		}

		return e.complexity.Server.Access(childComplexity), true

	case "Server.allowAutoUpdate":
		if e.complexity.Server.AllowAutoUpdate == nil {
			break
		}

		return e.complexity.Server.AllowAutoUpdate(childComplexity), true

	case "Server.description":
		if e.complexity.Server.Description == nil {
			break
		}

		return e.complexity.Server.Description(childComplexity), true

	case "Server.id":
		if e.complexity.Server.ID == nil {
			break
		}

		return e.complexity.Server.ID(childComplexity), true

	case "Server.name":
		if e.complexity.Server.Name == nil {
			break
		}

		return e.complexity.Server.Name(childComplexity), true

	case "Server.serverOSAutoUpdatePolicy":
		if e.complexity.Server.ServerOSAutoUpdatePolicy == nil {
			break
		}

		return e.complexity.Server.ServerOSAutoUpdatePolicy(childComplexity), true

	case "ServerForAccess.description":
		if e.complexity.ServerForAccess.Description == nil {
			break
		}

		return e.complexity.ServerForAccess.Description(childComplexity), true

	case "ServerForAccess.ipAddress":
		if e.complexity.ServerForAccess.IPAddress == nil {
			break
		}

		return e.complexity.ServerForAccess.IPAddress(childComplexity), true

	case "ServerForAccess.listeners":
		if e.complexity.ServerForAccess.Listeners == nil {
			break
		}

		return e.complexity.ServerForAccess.Listeners(childComplexity), true

	case "ServerForAccess.name":
		if e.complexity.ServerForAccess.Name == nil {
			break
		}

		return e.complexity.ServerForAccess.Name(childComplexity), true

	case "ServerForAccess.statistics":
		if e.complexity.ServerForAccess.Statistics == nil {
			break
		}

		return e.complexity.ServerForAccess.Statistics(childComplexity), true

	case "ServerOSAutoUpdatePolicy.allAutoUpdateEnabled":
		if e.complexity.ServerOSAutoUpdatePolicy.AllAutoUpdateEnabled == nil {
			break
		}

		return e.complexity.ServerOSAutoUpdatePolicy.AllAutoUpdateEnabled(childComplexity), true

	case "ServerOSAutoUpdatePolicy.osAutoUpdateEnabled":
		if e.complexity.ServerOSAutoUpdatePolicy.OsAutoUpdateEnabled == nil {
			break
		}

		return e.complexity.ServerOSAutoUpdatePolicy.OsAutoUpdateEnabled(childComplexity), true

	case "ServerOSAutoUpdatePolicy.osAutoUpdateHour":
		if e.complexity.ServerOSAutoUpdatePolicy.OsAutoUpdateHour == nil {
			break
		}

		return e.complexity.ServerOSAutoUpdatePolicy.OsAutoUpdateHour(childComplexity), true

	case "ServerOSAutoUpdatePolicy.restartAfterUpdate":
		if e.complexity.ServerOSAutoUpdatePolicy.RestartAfterUpdate == nil {
			break
		}

		return e.complexity.ServerOSAutoUpdatePolicy.RestartAfterUpdate(childComplexity), true

	case "ServerOSAutoUpdatePolicy.securityAutoUpdateEnabled":
		if e.complexity.ServerOSAutoUpdatePolicy.SecurityAutoUpdateEnabled == nil {
			break
		}

		return e.complexity.ServerOSAutoUpdatePolicy.SecurityAutoUpdateEnabled(childComplexity), true

	case "SystemConfig.aadConfig":
		if e.complexity.SystemConfig.AadConfig == nil {
			break
		}

		return e.complexity.SystemConfig.AadConfig(childComplexity), true

	case "SystemConfig.cliApiConfig":
		if e.complexity.SystemConfig.CliAPIConfig == nil {
			break
		}

		return e.complexity.SystemConfig.CliAPIConfig(childComplexity), true

	case "SystemConfig.lighthouses":
		if e.complexity.SystemConfig.Lighthouses == nil {
			break
		}

		return e.complexity.SystemConfig.Lighthouses(childComplexity), true

	case "SystemConfig.maximumCertificateValidity":
		if e.complexity.SystemConfig.MaximumCertificateValidity == nil {
			break
		}

		return e.complexity.SystemConfig.MaximumCertificateValidity(childComplexity), true

	case "SystemConfig.networkCidr":
		if e.complexity.SystemConfig.NetworkCidr == nil {
			break
		}

		return e.complexity.SystemConfig.NetworkCidr(childComplexity), true

	case "User.description":
		if e.complexity.User.Description == nil {
			break
		}

		return e.complexity.User.Description(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.origin":
		if e.complexity.User.Origin == nil {
			break
		}

		return e.complexity.User.Origin(childComplexity), true

	case "User.roles":
		if e.complexity.User.Roles == nil {
			break
		}

		return e.complexity.User.Roles(childComplexity), true

	case "User.upn":
		if e.complexity.User.Upn == nil {
			break
		}

		return e.complexity.User.Upn(childComplexity), true

	case "User.userAccesses":
		if e.complexity.User.UserAccesses == nil {
			break
		}

		return e.complexity.User.UserAccesses(childComplexity), true

	case "UserAccess.accesses":
		if e.complexity.UserAccess.Accesses == nil {
			break
		}

		return e.complexity.UserAccess.Accesses(childComplexity), true

	case "UserAccess.changed":
		if e.complexity.UserAccess.Changed == nil {
			break
		}

		return e.complexity.UserAccess.Changed(childComplexity), true

	case "UserAccess.description":
		if e.complexity.UserAccess.Description == nil {
			break
		}

		return e.complexity.UserAccess.Description(childComplexity), true

	case "UserAccess.fwConfig":
		if e.complexity.UserAccess.FwConfig == nil {
			break
		}

		return e.complexity.UserAccess.FwConfig(childComplexity), true

	case "UserAccess.groups":
		if e.complexity.UserAccess.Groups == nil {
			break
		}

		return e.complexity.UserAccess.Groups(childComplexity), true

	case "UserAccess.id":
		if e.complexity.UserAccess.ID == nil {
			break
		}

		return e.complexity.UserAccess.ID(childComplexity), true

	case "UserAccess.name":
		if e.complexity.UserAccess.Name == nil {
			break
		}

		return e.complexity.UserAccess.Name(childComplexity), true

	case "UserAccess.serversForAccess":
		if e.complexity.UserAccess.ServersForAccess == nil {
			break
		}

		return e.complexity.UserAccess.ServersForAccess(childComplexity), true

	case "UserAccess.userAccessTemplate":
		if e.complexity.UserAccess.UserAccessTemplate == nil {
			break
		}

		return e.complexity.UserAccess.UserAccessTemplate(childComplexity), true

	case "UserAccess.validFrom":
		if e.complexity.UserAccess.ValidFrom == nil {
			break
		}

		return e.complexity.UserAccess.ValidFrom(childComplexity), true

	case "UserAccess.validTo":
		if e.complexity.UserAccess.ValidTo == nil {
			break
		}

		return e.complexity.UserAccess.ValidTo(childComplexity), true

	case "UserAccessDeviceInfo.access":
		if e.complexity.UserAccessDeviceInfo.Access == nil {
			break
		}

		return e.complexity.UserAccessDeviceInfo.Access(childComplexity), true

	case "UserAccessDeviceInfo.caPublicKey":
		if e.complexity.UserAccessDeviceInfo.CaPublicKey == nil {
			break
		}

		return e.complexity.UserAccessDeviceInfo.CaPublicKey(childComplexity), true

	case "UserAccessDeviceInfo.certificate":
		if e.complexity.UserAccessDeviceInfo.Certificate == nil {
			break
		}

		return e.complexity.UserAccessDeviceInfo.Certificate(childComplexity), true

	case "UserAccessDeviceInfo.lighthouseIp":
		if e.complexity.UserAccessDeviceInfo.LighthouseIP == nil {
			break
		}

		return e.complexity.UserAccessDeviceInfo.LighthouseIP(childComplexity), true

	case "UserAccessDeviceInfo.lighthousePort":
		if e.complexity.UserAccessDeviceInfo.LighthousePort == nil {
			break
		}

		return e.complexity.UserAccessDeviceInfo.LighthousePort(childComplexity), true

	case "UserAccessDeviceInfo.lighthousePrivateIp":
		if e.complexity.UserAccessDeviceInfo.LighthousePrivateIP == nil {
			break
		}

		return e.complexity.UserAccessDeviceInfo.LighthousePrivateIP(childComplexity), true

	case "UserAccessTemplate.changed":
		if e.complexity.UserAccessTemplate.Changed == nil {
			break
		}

		return e.complexity.UserAccessTemplate.Changed(childComplexity), true

	case "UserAccessTemplate.description":
		if e.complexity.UserAccessTemplate.Description == nil {
			break
		}

		return e.complexity.UserAccessTemplate.Description(childComplexity), true

	case "UserAccessTemplate.fwConfig":
		if e.complexity.UserAccessTemplate.FwConfig == nil {
			break
		}

		return e.complexity.UserAccessTemplate.FwConfig(childComplexity), true

	case "UserAccessTemplate.groups":
		if e.complexity.UserAccessTemplate.Groups == nil {
			break
		}

		return e.complexity.UserAccessTemplate.Groups(childComplexity), true

	case "UserAccessTemplate.id":
		if e.complexity.UserAccessTemplate.ID == nil {
			break
		}

		return e.complexity.UserAccessTemplate.ID(childComplexity), true

	case "UserAccessTemplate.name":
		if e.complexity.UserAccessTemplate.Name == nil {
			break
		}

		return e.complexity.UserAccessTemplate.Name(childComplexity), true

	case "UserAccessTemplate.validFrom":
		if e.complexity.UserAccessTemplate.ValidFrom == nil {
			break
		}

		return e.complexity.UserAccessTemplate.ValidFrom(childComplexity), true

	case "UserAccessTemplate.validTo":
		if e.complexity.UserAccessTemplate.ValidTo == nil {
			break
		}

		return e.complexity.UserAccessTemplate.ValidTo(childComplexity), true

	case "UserStatistic.date":
		if e.complexity.UserStatistic.Date == nil {
			break
		}

		return e.complexity.UserStatistic.Date(childComplexity), true

	case "UserStatistic.hour":
		if e.complexity.UserStatistic.Hour == nil {
			break
		}

		return e.complexity.UserStatistic.Hour(childComplexity), true

	case "UserStatistic.usersOnline":
		if e.complexity.UserStatistic.UsersOnline == nil {
			break
		}

		return e.complexity.UserStatistic.UsersOnline(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAadConfigData,
		ec.unmarshalInputAccessDeviceData,
		ec.unmarshalInputAccessListenerData,
		ec.unmarshalInputCliApiConfigData,
		ec.unmarshalInputFwConfigData,
		ec.unmarshalInputFwConfigRuleData,
		ec.unmarshalInputGroupData,
		ec.unmarshalInputInviteUserData,
		ec.unmarshalInputServerAccessData,
		ec.unmarshalInputServerData,
		ec.unmarshalInputServerOSAutoUpdatePolicyData,
		ec.unmarshalInputSystemConfigData,
		ec.unmarshalInputUserAccessData,
		ec.unmarshalInputUserAccessTemplateData,
		ec.unmarshalInputUserData,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphqls", Input: `"""
The javascript ` + "`" + `Date` + "`" + ` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

"""
Base interface for nodes that can be retrieved by ID.
"""
interface Node {
  """Numeric ID"""
  id: Int!
}

"""
Code list item.
"""
type CodeListItem{
  "Numeric ID"
  id: Int!
  "Name of the record"
  name: String!
}

"""
Cost usage item.
"""
type CostUsageItem {
  "YearMonth"
  yearMonth: String!
  "UPN"
  upn: String!
  "Is user (false means server)"
  isUser: Boolean!
  "Hours spend in the mesh"
  hours: Float!
  "Cost"
  cost: Float!
}

"""
Cost usage month item.
"""
type CostUsageMonthItem {
  "YearMonth"
  yearMonth: String!
  "Cost"
  cost: Float!
  "Cost usage items for resources in mesh"
  costUsageItems: [CostUsageItem!]!
}

"""
Firewall configuration
"""
type FwConfig implements Node {
  "Numeric ID"
  id: Int!
  "Friendly name of the configuration"
  name: String
  "Rules for outgoing communication"
  fwConfigOuts: [FwConfigRule!]!
  "Rules for incoming communication"
  fwConfigIns: [FwConfigRule!]!
  "Date and time of the last modification to this configuration"
  changed: DateTime!
}

"""
Firewall rule
"""
type FwConfigRule {
  "Port to / from which the communication is comming"
  port: String!
  "Communication protocol"
  proto: String!
  """Remote hostname, "any" or "group" """
  host: String!
  """Groups to / from which the communication is allowed if host is set to "group" """
  groups: [Group!]
}

"""
Group of entities.
"""
type Group implements Node {
  "Numeric ID"
  id: Int!
  "Name of the group"
  name: String!
  "Optional description of the group"
  description: String
}

"""
Access statistic.
"""
type AccessStatistic {
  "Nebula tunnel is connected to lighthouse"
  isConnectd: Boolean
  "Communication over WebSocket underlay tunnel - communication over restrictive network"
  isOverRestrictiveNetwork: Boolean
  "Last contact from client"
  lastContact: DateTime
  "Last contact from client from now in seconds"
  lastContactFromNow: Int
}

"""
Access device info.
"""
type AccessDevice {
  "Device name"
  name: String!
  "Device Id for communication with shieldoo"
  deviceId: String!
  "Device OS type - [windows,darwin,linux,android,ios,synology]"
  deviceOSType: String!
  "Device OS"
  deviceOS: String!
  "Device client software version"
  deviceSWVersion: String!
  "Last contact from device - login message"
  contacted: DateTime
  "OS Auto update statistics"
  osAutoUpdate: OsAutoUpdate
}

"""
OS Auto update statistics data.
"""
type OsAutoUpdate {
  "OS type - [windows,darwin,linux,android,ios,synology]"
	osType: String!
  "OS name"
	name: String!
  "OS version"
  version: String!
  "OS description"
  description: String!
  "Last update date"
  lastUpdate: DateTime!
  "Last update output"
  lastUpdateOutput: String!
  "Last update success"
  lastUpdateSuccess: Boolean!
  "Security updates count"
  securityUpdatesCount: Int!
  "Other updates count"
  otherUpdatesCount: Int!
  "Security updates"
  securityUpdates: [String!]!
  "Other updates"
  otherUpdates: [String!]!
}

"""
Definition of the access rules for a single entity in the mesh.
One entity can eventually have multiple accesses, e.g. for test and prod environments.
"""
type Access {
  "Numeric ID"
  id: Int!
  "Name"
  name: String!
  "IP address assigned to the entity"
  ipAddress: String!
  "Fully Qualified Domain Name of the entity"
  fqdn: String!
  "List of additional hostnames for the entity"
  additionalHostnames: [String!]!
  "Optional description of the access definition"
  description: String
  "Groups that the entity is a member of"
  groups: [Group!]!
  "Firewall configuration"
  fwConfig: FwConfig!
  "Date and time from which this access definition is valid in the mesh"
  validFrom: DateTime!
  "Date and time after which this access definition is no longer valid in the mesh"
  validTo: DateTime!
  "Date and time of the last modification to this access"
  changed: DateTime!
  "Optional access listeners allowing communication forwarding (access box)"
  listeners: [AccessListener!]!
  "Base64 encoded configuration data for this access"
  config: String
  "Setting for nebula communication - punch back mode"
  punchBack: Boolean!
  "Setting for nebula communication - work on restrictive network"
  restrictiveNetwork: Boolean!
  "Access connection` + "`" + `s statistics"
  statistics: AccessStatistic
  "Device Access connection` + "`" + `s metadata"
  deviceInfo: AccessDevice
}

"""
Servers accessed by user
"""
type ServerForAccess {
  "Unique name of server"
  name: String!
  "Servers' mesh IP address"
  ipAddress: String!
  "Optional description"
  description: String
  "Optional access listeners allowing communication forwarding (access box)"
  listeners: [AccessListener!]!
  "Access connection` + "`" + `s statistics"
  statistics: AccessStatistic
}

"""
Definition of the access rules for a single user in the mesh.
One user can eventually have multiple user-accesses, e.g. for test and prod environments.
"""
type UserAccess {
  "Numeric ID"
  id: Int!
  "Name"
  name: String!
  "Optional description of the access definition"
  description: String
  "Groups that the entity is a member of"
  groups: [Group!]!
  "Firewall configuration"
  fwConfig: FwConfig!
  "Date and time from which this access definition is valid in the mesh"
  validFrom: DateTime!
  "Date and time after which this access definition is no longer valid in the mesh"
  validTo: DateTime!
  "Date and time of the last modification to this access"
  changed: DateTime!
  "Link to parent UserAccessTemplate"
  userAccessTemplate: UserAccessTemplate!
  "Accesses associated to this UserAccess"
  accesses: [Access!]!
  "Servers for access - resources which can be accessed by user"
  serversForAccess: [ServerForAccess!]!
}

"""
Definition of the template access rules for a user entity in the mesh.
"""
type UserAccessTemplate {
  "Numeric ID"
  id: Int!
  "Name"
  name: String!
  "Optional description of the access definition"
  description: String
  "Groups that the entity is a member of"
  groups: [Group!]!
  "Firewall configuration"
  fwConfig: FwConfig!
  "Date and time from which this access definition is valid in the mesh"
  validFrom: DateTime!
  "Date and time after which this access definition is no longer valid in the mesh"
  validTo: DateTime!
  "Date and time of the last modification to this access"
  changed: DateTime!
}

"""
Access listener type defines type of connected device
"""
type AccessListenerType {
  "Numeric ID"
  id: Int!
  "Glyph - for mapping to icon"
  glyph: String!
  "Name / description of item"
  name: String!
}

"""
Access listener defines rules for communication forwarding (access box)
"""
type AccessListener {
  "Port on which the server is listening"
  listenPort: Int
  "Communication protocol"
  protocol: String
  "Port to which the communication is to be forwarded"
  forwardPort: Int
  "Name of the host to which the communication is to be forwarded"
  forwardHost: String
  "Mapping to AccessListenerType"
  accessListenerType: AccessListenerType
  "Description"
  description: String
}

"""
Entity in the mesh; It may be a User or a Server.
"""
interface Entity {
  "Numeric ID"
  id: Int!
  "Display name of the entity"
  name: String!
  "Optional description of the entity"
  description: String
}

"""
User of the system (client entity)
"""
type User implements Entity {
  "Numeric ID"
  id: Int!
  "User's email"
  upn: String!
  "User's name"
  name: String!
  "Optional user description"
  description: String
  "UserAccess definitions issued for this user"
  userAccesses: [UserAccess!]!
  "Origin of account - from authentication - google/microsoft"
  origin: String
  "User roles"
  roles: [String]!
}

"""
Server in the mesh (device entity)
"""
type Server implements Entity {
  "Numeric ID"
  id: Int!
  "Unique name of the server"
  name: String!
  "Setting for app management - allow client to autoupdate"
  allowAutoUpdate: Boolean!
  "Optional server description"
  description: String
  "Access definition issued for this server"
  access: Access!
  "Server OS auto update policy"
  serverOSAutoUpdatePolicy: ServerOSAutoUpdatePolicy!
}

"""
Server OS auto update policy
"""
type ServerOSAutoUpdatePolicy {
  "OS auto update enabled"
  osAutoUpdateEnabled: Boolean!
  "OS auto update hour"
  osAutoUpdateHour: Int!
  "Security auto update enabled"
  securityAutoUpdateEnabled: Boolean!
  "All auto update enabled"
  allAutoUpdateEnabled: Boolean!
  "Restart after update"
  restartAfterUpdate: Boolean!
}

"""
Lighthouse entity
"""
type Lighthouse {
  "Public IP address"
  publicIp: String!
  "Nebula listening UDP port"
  port: Int!
  "Internal IP address in mesh"
  ipAddress: String!
}

"""
AAD configuration data
"""
type AadConfig {
  "AAD integration enabled"
  isEnabled: Boolean!
  "AAD application ID"
  clientId: String!
  "AAD application secret - we are showing only first 3 characters from secret"
  clientSecret: String!
  "AAD tenant ID"
  tenantId: String!
  "AAD admin group object ID"
  adminGroupObjectId: String!
  "Last processing message"
  lastProcessingMessage: String!
}

"""
CLI API configuration data
"""
type CliApiConfig {
  "CLI API integration enabled"
  isEnabled: Boolean!
  "CLI API URL"
  url: String!
  "CLI API Key - we are showing only first 3 characters from key when querying, full key returned when setting"
  apiKey: String!
}

"""
System Configuration attributes
"""
type SystemConfig {
  "Network mesh CIDR"
  networkCidr: String!
  "List of lighthouses"
  lighthouses: [Lighthouse]!
  "Maximum CA DateTime validity - Accesses cannot have validity after this date"
  maximumCertificateValidity: DateTime!
  "AAD configuration"
  aadConfig: AadConfig!
  "CLI API configuration"
  cliApiConfig: CliApiConfig!
}

"""
Log data
"""
type LogItem {
  "Unique ID"
  id: Int!
  "UPN generated event"
  upn: String!
  "Log data"
  data: String!
  "Date and time when event was created"
  created: DateTime!
}

"""
Config data
"""
type ConfigItem {
  "Max DB records"
  maxDBRecords: Int!
  "Tenant ID"
  tenantId: String!
  "Full tenant name"
  tenantName: String!
  "Max certificate validity - max value for ValidTo for access"
  maxCertificateValidity: DateTime!
  "Integration with AAD or other identity platform enabled"
  identityImportEnabled: Boolean!
}

"""
User connection statistics items
"""
type UserStatistic {
  "Date"
  date: String!
  "Hour"
  hour: Int!
  "Number of users online"
  usersOnline: Int!
}

"""
Admin dashboard data
"""
type AdminDashboard {
  "Number of users"
  users: Int!
  "Number of servers"
  servers: Int!
  "Number of invited users"
  invitedUsers: Int!
  "User connection statistics"
  userStatistics: [UserStatistic]!
}

"""
Queries
"""
type Query {
  "Get Month cost usage data"
  monthCostUsage: [CostUsageMonthItem!]!

  "Configuration data"
  config: ConfigItem!

  "Admin dashboard data"
  adminDashboard: AdminDashboard!

  "Code list groups"
  codelistGroups: [CodeListItem!]!

  "Code list firewalls"
  codelistFirewalls: [CodeListItem!]!

  "Code list UserAccessTemplates"
  codelistUserAccessTemplates: [CodeListItem!]!

  "Search telemetry log"
  telemetryLogs(
    "Optional filter - To query field content, use Field=Value for a 'LIKE' comparison or Field~Value for a strict equality. To query multiple fields, separate them with a comma. Nested fields are separated by dot, e.g. CurrentObject.ID=1,Entity=Access"
    filter: String
    "Optional upn filter"
    upn: String
    "Optional created from filter"
    createdFrom: DateTime
    "Optional created to filter"
    createdTo: DateTime
  ): [LogItem!]!

  "Search security log"
  securityLogs(
    "Optional filter - To query field content, use Field=Value for a 'LIKE' comparison or Field~Value for a strict equality. To query multiple fields, separate them with a comma. Nested fields are separated by dot, e.g. CurrentObject.ID=1,Entity=Access"
    filter: String
    "Optional upn filter"
    upn: String
    "Optional created from filter"
    createdFrom: DateTime
    "Optional created to filter"
    createdTo: DateTime
  ): [LogItem!]!

  "Get system Configuration data"
  systemConfig: SystemConfig!

  "List of users"
  users(
    "Optional user name filter"
    name: String
    "Optional origin filter"
    origin: String
  ): [User!]!

  "List of servers"
  servers(
    "Optional server name filter"
    name: String
  ): [Server!]!

  "Retrieve a current user info"
  me: User!

  "Retrieve a concrete user by its ID"
  server(id: Int!): Server!

  "Retrieve a concrete entity by its ID"
  user(id: Int!): User!

  "Retrieve a group by its ID"
  group(id: Int!): Group!

  "List of groups"
  groups(
    "Optional group name filter"
    name: String
  ): [Group!]!

  "List of access listener types"
  accessListenerTypes(
    "Optional name filter"
    name: String
  ): [AccessListenerType!]!

  "Retrieve a UserAccessTemplate by its ID"
  userAccessTemplate(id: Int!): UserAccessTemplate!

  "List of user access templates"
  userAccessTemplates(
    "Optional user access template name filter"
    name: String
  ): [UserAccessTemplate!]!

  "Retrieve a firewall configuration by its ID"
  firewallConfiguration(id: Int!): FwConfig!

  "List firewall configurations"
  firewallConfigurations(
    "Optional configuration name filter"
    name: String
  ): [FwConfig!]!
}

"""
Data needed to create a new or update an existing group
"""
input GroupData {
  "ID of the group if it already exists"
  id: Int
  "Name of the group"
  name: String!
  "Optional group description"
  description: String
}

"""
Data needed to create a new or update an existing user
"""
input UserData {
  "ID of the user if it already exists"
  id: Int
  "Unique name of the entity"
  upn: String!
  "Display name of the entity"
  name: String!
  "Optional entity description"
  description: String
  "Origin of account - from authentication - google/microsoft"
  origin: String
  "User roles"
  roles: [String]!
}

"""
Data needed to create a new or update an existing user
"""
input InviteUserData {
  "ID of the user if it already exists"
  id: Int
  "Unique name of the entity"
  upn: String!
  "Display name of the entity"
  name: String!
  "Optional entity description"
  description: String
  "User roles"
  roles: [String]!
  "ID of parent UserAccessTemplate object - if is empty than we will use default UserAccessTemplate"
  userAccessTemplateId: Int
}

"""
Data needed to create a new or update an existing server
"""
input ServerData {
  "ID of the server if it already exists"
  id: Int
  "Unique name of the server"
  name: String!
  "Setting for app management - allow client to autoupdate"
  allowAutoUpdate: Boolean!
  "Optional entity description"
  description: String
  "Server access profile"
  access: ServerAccessData
  "Server OS auto update policy"
  osAutoUpdatePolicy: ServerOSAutoUpdatePolicyData
}

"""
Data needed to create a new or update an existing server OS auto update policy
"""
input ServerOSAutoUpdatePolicyData {
  "OS auto update enabled"
  osAutoUpdateEnabled: Boolean!
  "OS auto update hour"
  osAutoUpdateHour: Int!
  "Security auto update enabled"
  securityAutoUpdateEnabled: Boolean!
  "All auto update enabled"
  allAutoUpdateEnabled: Boolean!
  "Restart after update"
  restartAfterUpdate: Boolean!
}

"""
Data necessary for creating a new or updating an existing firewall configuration
"""
input FwConfigData {
  "ID of the configuration if it already exists"
  id: Int
  "Friendly name of the configuration"
  name: String
  "Rules for outgoing communication"
  fwConfigOuts: [FwConfigRuleData!]!
  "Rules for incoming communication"
  fwConfigIns: [FwConfigRuleData!]!
}

"""
Data necessary for creating a firewall config rule
"""
input FwConfigRuleData {
  "Port to / from which the communication is comming"
  port: String!
  "Communication protocol"
  proto: String!
  """Remote hostname, "any" or "group" """
  host: String!
  """Groups to / from which the communication is allowed if host is set to "group" """
  groups: [GroupData!]
}

"""
Data necessary for creating an access listener
"""
input AccessListenerData {
  "Port on which the server is listening"
  listenPort: Int!
  "Communication protocol"
  protocol: String!
  "Port to which the communication is to be forwarded"
  forwardPort: Int!
  "Name of the host to which the communication is to be forwarded"
  forwardHost: String!
  "ID of access listener type"
  accessListenerTypeId: Int!
  "Description"
  description: String!
}

"""
Data necessary for creating or updating an server-access definition
"""
input ServerAccessData {
  "IP address to be assigned to the entity or null if one should be taken from the pool"
  ipAddress: String
  "Additional hostnames for the entity"
  additionalHostnames: [String!]!
  "Optional description of the access definition"
  description: String
  "IDs of the groups that the entity is a member of"
  groupsIds: [Int!]!
  "ID of the firewall configuration"
  fwConfigId: Int!
  "Date and time after which this access definition is no longer valid in the mesh"
  validTo: DateTime!
  "Optional access listeners allowing communication forwarding (access box)"
  listeners: [AccessListenerData!]!
  "Setting for nebula communication - punch back mode"
  punchBack: Boolean!
  "Setting for nebula communication - work on restrictive network"
  restrictiveNetwork: Boolean!
}

"""
Data necessary for creating or updating an access definition
"""
input UserAccessData {
  "ID of the access if it already exists"
  id: Int
  "Name"
  name: String!
  "Optional description of the access definition"
  description: String
  "IDs of the groups that the entity is a member of"
  groupsIds: [Int!]!
  "ID of the firewall configuration"
  fwConfigId: Int!
  "Date and time after which this access definition is no longer valid in the mesh"
  validTo: DateTime!
  "ID of parent UserAccessTemplate object"
  userAccessTemplateId: Int
  "ID of entity"
  entityId: Int!
}

"""
Data necessary for creating or updating an access definition
"""
input UserAccessTemplateData {
  "ID of the access if it already exists"
  id: Int
  "Name"
  name: String!
  "Optional description of the access definition"
  description: String
  "IDs of the groups that the entity is a member of"
  groupsIds: [Int!]!
  "ID of the firewall configuration"
  fwConfigId: Int!
  "Date and time after which this access definition is no longer valid in the mesh"
  validTo: DateTime!
  "Flag if record is deleted"
  deleted: Boolean!
}

"""
Data necessary for changing system config
"""
input SystemConfigData {
  "CIDR"
  networkCidr: String!
}

"""
Data necessary for changing AAD configuration 
"""
input AadConfigData {
  "AAD integration enabled"
  isEnabled: Boolean!
  "AAD application ID"
  clientId: String!
  "AAD application secret"
  clientSecret: String!
  "AAD tenant ID"
  tenantId: String!
  "AAD admin group object ID"
  adminGroupObjectId: String!
}

"""
Data necessary for changing CLI API configuration 
"""
input CliApiConfigData {
  "CLI API integration enabled"
  enabled: Boolean!
}

"""
Data necessary for creating users' device access and info.
"""
input AccessDeviceData {
  "Device name"
  name: String!
  "Device Id for communication with shieldoo"
  deviceId: String!
  "Device OS type - [windows,darwin,linux,android,ios,synology]"
  deviceOSType: String!
  "Device OS - full name"
  deviceOS: String!
  "Device client software version"
  deviceSWVersion: String!
  "Last contact from device - login message"
  contacted: DateTime
}

"""
Result data for creating user access device.
"""
type UserAccessDeviceInfo {
  "Access"
  access: Access!
  "Certificate data"
  certificate: String!
  "CA public key"
  caPublicKey: String!
  "Lighthouse public IP"
  lighthouseIp: String!
  "Lighthouse port"
  lighthousePort: Int!
  "Lighthouse private IP"
  lighthousePrivateIp: String!
}

"""
Mutations
"""
type Mutation {
  "Change system configuration"
  systemConfigSave(data: SystemConfigData!): SystemConfig!

  "Change AAD configuration"
  systemAadConfigSave(data: AadConfigData!): AadConfig!

  "Change CLI API configuration"
  systemCliApiConfigSave(data: CliApiConfigData!): CliApiConfig!

  "Invite user"
  userInvite(data: InviteUserData!): User!

  "Deletes an server with a given ID"
  serverDelete(id: Int!): Server!

  "Deletes an user with a given ID"
  userDelete(id: Int!): User!

  "Creates or updates a server"
  serverSave(data: ServerData): Server!

  "Creates or updates a user"
  userSave(data: UserData!): User!

  "Deletes a group with a given ID"
  groupDelete(id: Int!): Group!

  "Creates or updates a group"
  groupSave(data: GroupData!): Group!

  "Deletes a UserAccessTemplate with a given ID"
  userAccessTemplateDelete(id: Int!): UserAccessTemplate!

  "Creates or updates a UserAccessTemplate"
  userAccessTemplateSave(data: UserAccessTemplateData!): UserAccessTemplate!

  "Deletes a firewall configuration with a given ID"
  firewallConfigurationDelete(id: Int!): FwConfig!

  "Creates or updates a firewall configuration"
  firewallConfigurationSave(data: FwConfigData!): FwConfig!

  "Deletes an access definition with a given ID"
  userAccessDelete(id: Int!): UserAccess!

  "Creates or updates an access definition"
  userAccessSave(data: UserAccessData!): UserAccess!

  "Users' device save note"
  userDeviceSaveNote(
    "Access ID"
    id: Int!
    "Note"
    note: String!
  ): Access!

  "Users' device delete - delete device info and access data"
  userDeviceDelete(
    "Access ID"
    id: Int!
  ): Int!

  "Users' device create"
  userDeviceCreate(
    "ID of user access configuration"
    userAccessId: Int!
    "Users' device metadata"
    data: AccessDeviceData!
    "Public key for signing"
    publicKey: String
  ): UserAccessDeviceInfo!
}

schema {
  query: Query
  mutation: Mutation
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_firewallConfigurationDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_firewallConfigurationSave_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlmodel.FwConfigData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNFwConfigData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_groupDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_groupSave_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlmodel.GroupData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNGroupData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_serverDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_serverSave_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *gqlmodel.ServerData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalOServerData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_systemAadConfigSave_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlmodel.AadConfigData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNAadConfigData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAadConfigData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_systemCliApiConfigSave_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlmodel.CliAPIConfigData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNCliApiConfigData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCliAPIConfigData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_systemConfigSave_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlmodel.SystemConfigData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNSystemConfigData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐSystemConfigData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userAccessDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userAccessSave_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlmodel.UserAccessData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNUserAccessData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userAccessTemplateDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userAccessTemplateSave_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlmodel.UserAccessTemplateData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNUserAccessTemplateData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplateData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userDeviceCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["userAccessId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userAccessId"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userAccessId"] = arg0
	var arg1 gqlmodel.AccessDeviceData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg1, err = ec.unmarshalNAccessDeviceData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessDeviceData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["publicKey"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKey"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["publicKey"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_userDeviceDelete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userDeviceSaveNote_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["note"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["note"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_userInvite_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlmodel.InviteUserData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNInviteUserData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐInviteUserData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_userSave_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 gqlmodel.UserData
	if tmp, ok := rawArgs["data"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
		arg0, err = ec.unmarshalNUserData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserData(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["data"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_accessListenerTypes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_firewallConfiguration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_firewallConfigurations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_group_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_groups_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_securityLogs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["upn"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("upn"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upn"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["createdFrom"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdFrom"))
		arg2, err = ec.unmarshalODateTime2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["createdFrom"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["createdTo"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdTo"))
		arg3, err = ec.unmarshalODateTime2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["createdTo"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_server_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_servers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_telemetryLogs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["filter"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filter"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["upn"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("upn"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["upn"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["createdFrom"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdFrom"))
		arg2, err = ec.unmarshalODateTime2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["createdFrom"] = arg2
	var arg3 *string
	if tmp, ok := rawArgs["createdTo"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdTo"))
		arg3, err = ec.unmarshalODateTime2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["createdTo"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_userAccessTemplate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_userAccessTemplates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_users_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["origin"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("origin"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["origin"] = arg1
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AadConfig_isEnabled(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AadConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AadConfig_isEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AadConfig_isEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AadConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AadConfig_clientId(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AadConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AadConfig_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AadConfig_clientId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AadConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AadConfig_clientSecret(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AadConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AadConfig_clientSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientSecret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AadConfig_clientSecret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AadConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AadConfig_tenantId(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AadConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AadConfig_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AadConfig_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AadConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AadConfig_adminGroupObjectId(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AadConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AadConfig_adminGroupObjectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminGroupObjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AadConfig_adminGroupObjectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AadConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AadConfig_lastProcessingMessage(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AadConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AadConfig_lastProcessingMessage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastProcessingMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AadConfig_lastProcessingMessage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AadConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_id(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_ipAddress(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_ipAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_ipAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_fqdn(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_fqdn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fqdn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_fqdn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_additionalHostnames(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_additionalHostnames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalHostnames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_additionalHostnames(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_description(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_groups(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_fwConfig(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_fwConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FwConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.FwConfig)
	fc.Result = res
	return ec.marshalNFwConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_fwConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FwConfig_id(ctx, field)
			case "name":
				return ec.fieldContext_FwConfig_name(ctx, field)
			case "fwConfigOuts":
				return ec.fieldContext_FwConfig_fwConfigOuts(ctx, field)
			case "fwConfigIns":
				return ec.fieldContext_FwConfig_fwConfigIns(ctx, field)
			case "changed":
				return ec.fieldContext_FwConfig_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FwConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_validFrom(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_validFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_validFrom(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_validTo(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_validTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_validTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_changed(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_changed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Changed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_changed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_listeners(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_listeners(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Listeners, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.AccessListener)
	fc.Result = res
	return ec.marshalNAccessListener2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_listeners(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "listenPort":
				return ec.fieldContext_AccessListener_listenPort(ctx, field)
			case "protocol":
				return ec.fieldContext_AccessListener_protocol(ctx, field)
			case "forwardPort":
				return ec.fieldContext_AccessListener_forwardPort(ctx, field)
			case "forwardHost":
				return ec.fieldContext_AccessListener_forwardHost(ctx, field)
			case "accessListenerType":
				return ec.fieldContext_AccessListener_accessListenerType(ctx, field)
			case "description":
				return ec.fieldContext_AccessListener_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccessListener", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_config(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Config, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_punchBack(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_punchBack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PunchBack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_punchBack(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_restrictiveNetwork(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_restrictiveNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RestrictiveNetwork, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_restrictiveNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_statistics(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_statistics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Statistics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.AccessStatistic)
	fc.Result = res
	return ec.marshalOAccessStatistic2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessStatistic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_statistics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isConnectd":
				return ec.fieldContext_AccessStatistic_isConnectd(ctx, field)
			case "isOverRestrictiveNetwork":
				return ec.fieldContext_AccessStatistic_isOverRestrictiveNetwork(ctx, field)
			case "lastContact":
				return ec.fieldContext_AccessStatistic_lastContact(ctx, field)
			case "lastContactFromNow":
				return ec.fieldContext_AccessStatistic_lastContactFromNow(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccessStatistic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Access_deviceInfo(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Access) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Access_deviceInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.AccessDevice)
	fc.Result = res
	return ec.marshalOAccessDevice2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessDevice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Access_deviceInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Access",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_AccessDevice_name(ctx, field)
			case "deviceId":
				return ec.fieldContext_AccessDevice_deviceId(ctx, field)
			case "deviceOSType":
				return ec.fieldContext_AccessDevice_deviceOSType(ctx, field)
			case "deviceOS":
				return ec.fieldContext_AccessDevice_deviceOS(ctx, field)
			case "deviceSWVersion":
				return ec.fieldContext_AccessDevice_deviceSWVersion(ctx, field)
			case "contacted":
				return ec.fieldContext_AccessDevice_contacted(ctx, field)
			case "osAutoUpdate":
				return ec.fieldContext_AccessDevice_osAutoUpdate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccessDevice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessDevice_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessDevice_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessDevice_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessDevice_deviceId(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessDevice_deviceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessDevice_deviceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessDevice_deviceOSType(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessDevice_deviceOSType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceOSType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessDevice_deviceOSType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessDevice_deviceOS(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessDevice_deviceOS(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceOs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessDevice_deviceOS(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessDevice_deviceSWVersion(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessDevice_deviceSWVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceSWVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessDevice_deviceSWVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessDevice_contacted(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessDevice_contacted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Contacted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessDevice_contacted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessDevice_osAutoUpdate(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessDevice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessDevice_osAutoUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OsAutoUpdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.OsAutoUpdate)
	fc.Result = res
	return ec.marshalOOsAutoUpdate2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐOsAutoUpdate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessDevice_osAutoUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessDevice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "osType":
				return ec.fieldContext_OsAutoUpdate_osType(ctx, field)
			case "name":
				return ec.fieldContext_OsAutoUpdate_name(ctx, field)
			case "version":
				return ec.fieldContext_OsAutoUpdate_version(ctx, field)
			case "description":
				return ec.fieldContext_OsAutoUpdate_description(ctx, field)
			case "lastUpdate":
				return ec.fieldContext_OsAutoUpdate_lastUpdate(ctx, field)
			case "lastUpdateOutput":
				return ec.fieldContext_OsAutoUpdate_lastUpdateOutput(ctx, field)
			case "lastUpdateSuccess":
				return ec.fieldContext_OsAutoUpdate_lastUpdateSuccess(ctx, field)
			case "securityUpdatesCount":
				return ec.fieldContext_OsAutoUpdate_securityUpdatesCount(ctx, field)
			case "otherUpdatesCount":
				return ec.fieldContext_OsAutoUpdate_otherUpdatesCount(ctx, field)
			case "securityUpdates":
				return ec.fieldContext_OsAutoUpdate_securityUpdates(ctx, field)
			case "otherUpdates":
				return ec.fieldContext_OsAutoUpdate_otherUpdates(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OsAutoUpdate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessListener_listenPort(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessListener) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessListener_listenPort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ListenPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessListener_listenPort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessListener",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessListener_protocol(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessListener) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessListener_protocol(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Protocol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessListener_protocol(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessListener",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessListener_forwardPort(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessListener) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessListener_forwardPort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ForwardPort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessListener_forwardPort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessListener",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessListener_forwardHost(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessListener) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessListener_forwardHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ForwardHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessListener_forwardHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessListener",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessListener_accessListenerType(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessListener) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessListener_accessListenerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessListenerType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.AccessListenerType)
	fc.Result = res
	return ec.marshalOAccessListenerType2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessListener_accessListenerType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessListener",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AccessListenerType_id(ctx, field)
			case "glyph":
				return ec.fieldContext_AccessListenerType_glyph(ctx, field)
			case "name":
				return ec.fieldContext_AccessListenerType_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccessListenerType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessListener_description(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessListener) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessListener_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessListener_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessListener",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessListenerType_id(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessListenerType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessListenerType_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessListenerType_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessListenerType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessListenerType_glyph(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessListenerType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessListenerType_glyph(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Glyph, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessListenerType_glyph(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessListenerType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessListenerType_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessListenerType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessListenerType_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessListenerType_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessListenerType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessStatistic_isConnectd(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessStatistic_isConnectd(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsConnectd, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessStatistic_isConnectd(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessStatistic_isOverRestrictiveNetwork(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessStatistic_isOverRestrictiveNetwork(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOverRestrictiveNetwork, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessStatistic_isOverRestrictiveNetwork(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessStatistic_lastContact(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessStatistic_lastContact(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastContact, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalODateTime2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessStatistic_lastContact(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AccessStatistic_lastContactFromNow(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AccessStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AccessStatistic_lastContactFromNow(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastContactFromNow, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AccessStatistic_lastContactFromNow(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AccessStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminDashboard_users(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AdminDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminDashboard_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminDashboard_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminDashboard_servers(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AdminDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminDashboard_servers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Servers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminDashboard_servers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminDashboard_invitedUsers(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AdminDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminDashboard_invitedUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvitedUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminDashboard_invitedUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminDashboard_userStatistics(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.AdminDashboard) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminDashboard_userStatistics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserStatistics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.UserStatistic)
	fc.Result = res
	return ec.marshalNUserStatistic2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserStatistic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminDashboard_userStatistics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminDashboard",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_UserStatistic_date(ctx, field)
			case "hour":
				return ec.fieldContext_UserStatistic_hour(ctx, field)
			case "usersOnline":
				return ec.fieldContext_UserStatistic_usersOnline(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserStatistic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CliApiConfig_isEnabled(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CliAPIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CliApiConfig_isEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CliApiConfig_isEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CliApiConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CliApiConfig_url(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CliAPIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CliApiConfig_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CliApiConfig_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CliApiConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CliApiConfig_apiKey(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CliAPIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CliApiConfig_apiKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CliApiConfig_apiKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CliApiConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CodeListItem_id(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CodeListItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CodeListItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CodeListItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CodeListItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CodeListItem_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CodeListItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CodeListItem_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CodeListItem_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CodeListItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigItem_maxDBRecords(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ConfigItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigItem_maxDBRecords(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDBRecords, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigItem_maxDBRecords(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigItem_tenantId(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ConfigItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigItem_tenantId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigItem_tenantId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigItem_tenantName(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ConfigItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigItem_tenantName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TenantName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigItem_tenantName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigItem_maxCertificateValidity(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ConfigItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigItem_maxCertificateValidity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxCertificateValidity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigItem_maxCertificateValidity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfigItem_identityImportEnabled(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ConfigItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConfigItem_identityImportEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IdentityImportEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConfigItem_identityImportEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfigItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostUsageItem_yearMonth(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CostUsageItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CostUsageItem_yearMonth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.YearMonth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CostUsageItem_yearMonth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostUsageItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostUsageItem_upn(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CostUsageItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CostUsageItem_upn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Upn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CostUsageItem_upn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostUsageItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostUsageItem_isUser(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CostUsageItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CostUsageItem_isUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CostUsageItem_isUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostUsageItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostUsageItem_hours(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CostUsageItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CostUsageItem_hours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hours, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CostUsageItem_hours(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostUsageItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostUsageItem_cost(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CostUsageItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CostUsageItem_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CostUsageItem_cost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostUsageItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostUsageMonthItem_yearMonth(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CostUsageMonthItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CostUsageMonthItem_yearMonth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.YearMonth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CostUsageMonthItem_yearMonth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostUsageMonthItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostUsageMonthItem_cost(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CostUsageMonthItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CostUsageMonthItem_cost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CostUsageMonthItem_cost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostUsageMonthItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CostUsageMonthItem_costUsageItems(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.CostUsageMonthItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CostUsageMonthItem_costUsageItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CostUsageItems, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.CostUsageItem)
	fc.Result = res
	return ec.marshalNCostUsageItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCostUsageItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CostUsageMonthItem_costUsageItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CostUsageMonthItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "yearMonth":
				return ec.fieldContext_CostUsageItem_yearMonth(ctx, field)
			case "upn":
				return ec.fieldContext_CostUsageItem_upn(ctx, field)
			case "isUser":
				return ec.fieldContext_CostUsageItem_isUser(ctx, field)
			case "hours":
				return ec.fieldContext_CostUsageItem_hours(ctx, field)
			case "cost":
				return ec.fieldContext_CostUsageItem_cost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CostUsageItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FwConfig_id(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.FwConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FwConfig_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FwConfig_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FwConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FwConfig_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.FwConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FwConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FwConfig_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FwConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FwConfig_fwConfigOuts(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.FwConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FwConfig_fwConfigOuts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FwConfigOuts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.FwConfigRule)
	fc.Result = res
	return ec.marshalNFwConfigRule2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigRuleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FwConfig_fwConfigOuts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FwConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "port":
				return ec.fieldContext_FwConfigRule_port(ctx, field)
			case "proto":
				return ec.fieldContext_FwConfigRule_proto(ctx, field)
			case "host":
				return ec.fieldContext_FwConfigRule_host(ctx, field)
			case "groups":
				return ec.fieldContext_FwConfigRule_groups(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FwConfigRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FwConfig_fwConfigIns(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.FwConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FwConfig_fwConfigIns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FwConfigIns, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.FwConfigRule)
	fc.Result = res
	return ec.marshalNFwConfigRule2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigRuleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FwConfig_fwConfigIns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FwConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "port":
				return ec.fieldContext_FwConfigRule_port(ctx, field)
			case "proto":
				return ec.fieldContext_FwConfigRule_proto(ctx, field)
			case "host":
				return ec.fieldContext_FwConfigRule_host(ctx, field)
			case "groups":
				return ec.fieldContext_FwConfigRule_groups(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FwConfigRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FwConfig_changed(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.FwConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FwConfig_changed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Changed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FwConfig_changed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FwConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FwConfigRule_port(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.FwConfigRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FwConfigRule_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FwConfigRule_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FwConfigRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FwConfigRule_proto(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.FwConfigRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FwConfigRule_proto(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Proto, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FwConfigRule_proto(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FwConfigRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FwConfigRule_host(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.FwConfigRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FwConfigRule_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FwConfigRule_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FwConfigRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FwConfigRule_groups(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.FwConfigRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FwConfigRule_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.Group)
	fc.Result = res
	return ec.marshalOGroup2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FwConfigRule_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FwConfigRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_id(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Group_description(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Group) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Group_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Group_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Group",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lighthouse_publicIp(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Lighthouse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lighthouse_publicIp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PublicIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lighthouse_publicIp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lighthouse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lighthouse_port(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Lighthouse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lighthouse_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Port, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lighthouse_port(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lighthouse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Lighthouse_ipAddress(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Lighthouse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Lighthouse_ipAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Lighthouse_ipAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Lighthouse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogItem_id(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.LogItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogItem_upn(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.LogItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogItem_upn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Upn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogItem_upn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogItem_data(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.LogItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogItem_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogItem_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogItem_created(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.LogItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogItem_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogItem_created(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_systemConfigSave(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_systemConfigSave(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SystemConfigSave(rctx, fc.Args["data"].(gqlmodel.SystemConfigData))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.SystemConfig)
	fc.Result = res
	return ec.marshalNSystemConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐSystemConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_systemConfigSave(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "networkCidr":
				return ec.fieldContext_SystemConfig_networkCidr(ctx, field)
			case "lighthouses":
				return ec.fieldContext_SystemConfig_lighthouses(ctx, field)
			case "maximumCertificateValidity":
				return ec.fieldContext_SystemConfig_maximumCertificateValidity(ctx, field)
			case "aadConfig":
				return ec.fieldContext_SystemConfig_aadConfig(ctx, field)
			case "cliApiConfig":
				return ec.fieldContext_SystemConfig_cliApiConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SystemConfig", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_systemConfigSave_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_systemAadConfigSave(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_systemAadConfigSave(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SystemAadConfigSave(rctx, fc.Args["data"].(gqlmodel.AadConfigData))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.AadConfig)
	fc.Result = res
	return ec.marshalNAadConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAadConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_systemAadConfigSave(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isEnabled":
				return ec.fieldContext_AadConfig_isEnabled(ctx, field)
			case "clientId":
				return ec.fieldContext_AadConfig_clientId(ctx, field)
			case "clientSecret":
				return ec.fieldContext_AadConfig_clientSecret(ctx, field)
			case "tenantId":
				return ec.fieldContext_AadConfig_tenantId(ctx, field)
			case "adminGroupObjectId":
				return ec.fieldContext_AadConfig_adminGroupObjectId(ctx, field)
			case "lastProcessingMessage":
				return ec.fieldContext_AadConfig_lastProcessingMessage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AadConfig", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_systemAadConfigSave_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_systemCliApiConfigSave(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_systemCliApiConfigSave(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SystemCliAPIConfigSave(rctx, fc.Args["data"].(gqlmodel.CliAPIConfigData))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.CliAPIConfig)
	fc.Result = res
	return ec.marshalNCliApiConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCliAPIConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_systemCliApiConfigSave(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isEnabled":
				return ec.fieldContext_CliApiConfig_isEnabled(ctx, field)
			case "url":
				return ec.fieldContext_CliApiConfig_url(ctx, field)
			case "apiKey":
				return ec.fieldContext_CliApiConfig_apiKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CliApiConfig", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_systemCliApiConfigSave_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userInvite(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userInvite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserInvite(rctx, fc.Args["data"].(gqlmodel.InviteUserData))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userInvite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "upn":
				return ec.fieldContext_User_upn(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "description":
				return ec.fieldContext_User_description(ctx, field)
			case "userAccesses":
				return ec.fieldContext_User_userAccesses(ctx, field)
			case "origin":
				return ec.fieldContext_User_origin(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userInvite_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_serverDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_serverDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ServerDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.Server)
	fc.Result = res
	return ec.marshalNServer2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_serverDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Server_id(ctx, field)
			case "name":
				return ec.fieldContext_Server_name(ctx, field)
			case "allowAutoUpdate":
				return ec.fieldContext_Server_allowAutoUpdate(ctx, field)
			case "description":
				return ec.fieldContext_Server_description(ctx, field)
			case "access":
				return ec.fieldContext_Server_access(ctx, field)
			case "serverOSAutoUpdatePolicy":
				return ec.fieldContext_Server_serverOSAutoUpdatePolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Server", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_serverDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "upn":
				return ec.fieldContext_User_upn(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "description":
				return ec.fieldContext_User_description(ctx, field)
			case "userAccesses":
				return ec.fieldContext_User_userAccesses(ctx, field)
			case "origin":
				return ec.fieldContext_User_origin(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_serverSave(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_serverSave(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ServerSave(rctx, fc.Args["data"].(*gqlmodel.ServerData))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.Server)
	fc.Result = res
	return ec.marshalNServer2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_serverSave(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Server_id(ctx, field)
			case "name":
				return ec.fieldContext_Server_name(ctx, field)
			case "allowAutoUpdate":
				return ec.fieldContext_Server_allowAutoUpdate(ctx, field)
			case "description":
				return ec.fieldContext_Server_description(ctx, field)
			case "access":
				return ec.fieldContext_Server_access(ctx, field)
			case "serverOSAutoUpdatePolicy":
				return ec.fieldContext_Server_serverOSAutoUpdatePolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Server", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_serverSave_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userSave(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userSave(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserSave(rctx, fc.Args["data"].(gqlmodel.UserData))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userSave(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "upn":
				return ec.fieldContext_User_upn(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "description":
				return ec.fieldContext_User_description(ctx, field)
			case "userAccesses":
				return ec.fieldContext_User_userAccesses(ctx, field)
			case "origin":
				return ec.fieldContext_User_origin(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userSave_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_groupDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_groupDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GroupDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_groupDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_groupDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_groupSave(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_groupSave(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().GroupSave(rctx, fc.Args["data"].(gqlmodel.GroupData))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_groupSave(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_groupSave_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userAccessTemplateDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userAccessTemplateDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserAccessTemplateDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.UserAccessTemplate)
	fc.Result = res
	return ec.marshalNUserAccessTemplate2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userAccessTemplateDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserAccessTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_UserAccessTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_UserAccessTemplate_description(ctx, field)
			case "groups":
				return ec.fieldContext_UserAccessTemplate_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_UserAccessTemplate_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_UserAccessTemplate_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_UserAccessTemplate_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_UserAccessTemplate_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserAccessTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userAccessTemplateDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userAccessTemplateSave(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userAccessTemplateSave(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserAccessTemplateSave(rctx, fc.Args["data"].(gqlmodel.UserAccessTemplateData))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.UserAccessTemplate)
	fc.Result = res
	return ec.marshalNUserAccessTemplate2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userAccessTemplateSave(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserAccessTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_UserAccessTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_UserAccessTemplate_description(ctx, field)
			case "groups":
				return ec.fieldContext_UserAccessTemplate_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_UserAccessTemplate_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_UserAccessTemplate_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_UserAccessTemplate_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_UserAccessTemplate_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserAccessTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userAccessTemplateSave_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_firewallConfigurationDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_firewallConfigurationDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FirewallConfigurationDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.FwConfig)
	fc.Result = res
	return ec.marshalNFwConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_firewallConfigurationDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FwConfig_id(ctx, field)
			case "name":
				return ec.fieldContext_FwConfig_name(ctx, field)
			case "fwConfigOuts":
				return ec.fieldContext_FwConfig_fwConfigOuts(ctx, field)
			case "fwConfigIns":
				return ec.fieldContext_FwConfig_fwConfigIns(ctx, field)
			case "changed":
				return ec.fieldContext_FwConfig_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FwConfig", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_firewallConfigurationDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_firewallConfigurationSave(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_firewallConfigurationSave(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().FirewallConfigurationSave(rctx, fc.Args["data"].(gqlmodel.FwConfigData))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.FwConfig)
	fc.Result = res
	return ec.marshalNFwConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_firewallConfigurationSave(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FwConfig_id(ctx, field)
			case "name":
				return ec.fieldContext_FwConfig_name(ctx, field)
			case "fwConfigOuts":
				return ec.fieldContext_FwConfig_fwConfigOuts(ctx, field)
			case "fwConfigIns":
				return ec.fieldContext_FwConfig_fwConfigIns(ctx, field)
			case "changed":
				return ec.fieldContext_FwConfig_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FwConfig", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_firewallConfigurationSave_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userAccessDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userAccessDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserAccessDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.UserAccess)
	fc.Result = res
	return ec.marshalNUserAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userAccessDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserAccess_id(ctx, field)
			case "name":
				return ec.fieldContext_UserAccess_name(ctx, field)
			case "description":
				return ec.fieldContext_UserAccess_description(ctx, field)
			case "groups":
				return ec.fieldContext_UserAccess_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_UserAccess_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_UserAccess_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_UserAccess_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_UserAccess_changed(ctx, field)
			case "userAccessTemplate":
				return ec.fieldContext_UserAccess_userAccessTemplate(ctx, field)
			case "accesses":
				return ec.fieldContext_UserAccess_accesses(ctx, field)
			case "serversForAccess":
				return ec.fieldContext_UserAccess_serversForAccess(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserAccess", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userAccessDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userAccessSave(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userAccessSave(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserAccessSave(rctx, fc.Args["data"].(gqlmodel.UserAccessData))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.UserAccess)
	fc.Result = res
	return ec.marshalNUserAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userAccessSave(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserAccess_id(ctx, field)
			case "name":
				return ec.fieldContext_UserAccess_name(ctx, field)
			case "description":
				return ec.fieldContext_UserAccess_description(ctx, field)
			case "groups":
				return ec.fieldContext_UserAccess_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_UserAccess_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_UserAccess_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_UserAccess_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_UserAccess_changed(ctx, field)
			case "userAccessTemplate":
				return ec.fieldContext_UserAccess_userAccessTemplate(ctx, field)
			case "accesses":
				return ec.fieldContext_UserAccess_accesses(ctx, field)
			case "serversForAccess":
				return ec.fieldContext_UserAccess_serversForAccess(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserAccess", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userAccessSave_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userDeviceSaveNote(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userDeviceSaveNote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserDeviceSaveNote(rctx, fc.Args["id"].(int), fc.Args["note"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.Access)
	fc.Result = res
	return ec.marshalNAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userDeviceSaveNote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Access_id(ctx, field)
			case "name":
				return ec.fieldContext_Access_name(ctx, field)
			case "ipAddress":
				return ec.fieldContext_Access_ipAddress(ctx, field)
			case "fqdn":
				return ec.fieldContext_Access_fqdn(ctx, field)
			case "additionalHostnames":
				return ec.fieldContext_Access_additionalHostnames(ctx, field)
			case "description":
				return ec.fieldContext_Access_description(ctx, field)
			case "groups":
				return ec.fieldContext_Access_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_Access_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_Access_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_Access_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_Access_changed(ctx, field)
			case "listeners":
				return ec.fieldContext_Access_listeners(ctx, field)
			case "config":
				return ec.fieldContext_Access_config(ctx, field)
			case "punchBack":
				return ec.fieldContext_Access_punchBack(ctx, field)
			case "restrictiveNetwork":
				return ec.fieldContext_Access_restrictiveNetwork(ctx, field)
			case "statistics":
				return ec.fieldContext_Access_statistics(ctx, field)
			case "deviceInfo":
				return ec.fieldContext_Access_deviceInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Access", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userDeviceSaveNote_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userDeviceDelete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userDeviceDelete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserDeviceDelete(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userDeviceDelete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userDeviceDelete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_userDeviceCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_userDeviceCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UserDeviceCreate(rctx, fc.Args["userAccessId"].(int), fc.Args["data"].(gqlmodel.AccessDeviceData), fc.Args["publicKey"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.UserAccessDeviceInfo)
	fc.Result = res
	return ec.marshalNUserAccessDeviceInfo2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessDeviceInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_userDeviceCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "access":
				return ec.fieldContext_UserAccessDeviceInfo_access(ctx, field)
			case "certificate":
				return ec.fieldContext_UserAccessDeviceInfo_certificate(ctx, field)
			case "caPublicKey":
				return ec.fieldContext_UserAccessDeviceInfo_caPublicKey(ctx, field)
			case "lighthouseIp":
				return ec.fieldContext_UserAccessDeviceInfo_lighthouseIp(ctx, field)
			case "lighthousePort":
				return ec.fieldContext_UserAccessDeviceInfo_lighthousePort(ctx, field)
			case "lighthousePrivateIp":
				return ec.fieldContext_UserAccessDeviceInfo_lighthousePrivateIp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserAccessDeviceInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_userDeviceCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_osType(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_osType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OsType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_osType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_version(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_description(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_lastUpdate(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_lastUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_lastUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_lastUpdateOutput(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_lastUpdateOutput(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdateOutput, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_lastUpdateOutput(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_lastUpdateSuccess(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_lastUpdateSuccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdateSuccess, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_lastUpdateSuccess(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_securityUpdatesCount(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_securityUpdatesCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecurityUpdatesCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_securityUpdatesCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_otherUpdatesCount(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_otherUpdatesCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OtherUpdatesCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_otherUpdatesCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_securityUpdates(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_securityUpdates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecurityUpdates, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_securityUpdates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OsAutoUpdate_otherUpdates(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.OsAutoUpdate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OsAutoUpdate_otherUpdates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OtherUpdates, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OsAutoUpdate_otherUpdates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OsAutoUpdate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_monthCostUsage(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_monthCostUsage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MonthCostUsage(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.CostUsageMonthItem)
	fc.Result = res
	return ec.marshalNCostUsageMonthItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCostUsageMonthItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_monthCostUsage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "yearMonth":
				return ec.fieldContext_CostUsageMonthItem_yearMonth(ctx, field)
			case "cost":
				return ec.fieldContext_CostUsageMonthItem_cost(ctx, field)
			case "costUsageItems":
				return ec.fieldContext_CostUsageMonthItem_costUsageItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CostUsageMonthItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_config(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_config(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Config(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.ConfigItem)
	fc.Result = res
	return ec.marshalNConfigItem2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐConfigItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_config(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxDBRecords":
				return ec.fieldContext_ConfigItem_maxDBRecords(ctx, field)
			case "tenantId":
				return ec.fieldContext_ConfigItem_tenantId(ctx, field)
			case "tenantName":
				return ec.fieldContext_ConfigItem_tenantName(ctx, field)
			case "maxCertificateValidity":
				return ec.fieldContext_ConfigItem_maxCertificateValidity(ctx, field)
			case "identityImportEnabled":
				return ec.fieldContext_ConfigItem_identityImportEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConfigItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminDashboard(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminDashboard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AdminDashboard(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.AdminDashboard)
	fc.Result = res
	return ec.marshalNAdminDashboard2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAdminDashboard(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminDashboard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_AdminDashboard_users(ctx, field)
			case "servers":
				return ec.fieldContext_AdminDashboard_servers(ctx, field)
			case "invitedUsers":
				return ec.fieldContext_AdminDashboard_invitedUsers(ctx, field)
			case "userStatistics":
				return ec.fieldContext_AdminDashboard_userStatistics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminDashboard", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_codelistGroups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_codelistGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CodelistGroups(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.CodeListItem)
	fc.Result = res
	return ec.marshalNCodeListItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCodeListItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_codelistGroups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CodeListItem_id(ctx, field)
			case "name":
				return ec.fieldContext_CodeListItem_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CodeListItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_codelistFirewalls(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_codelistFirewalls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CodelistFirewalls(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.CodeListItem)
	fc.Result = res
	return ec.marshalNCodeListItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCodeListItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_codelistFirewalls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CodeListItem_id(ctx, field)
			case "name":
				return ec.fieldContext_CodeListItem_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CodeListItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_codelistUserAccessTemplates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_codelistUserAccessTemplates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CodelistUserAccessTemplates(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.CodeListItem)
	fc.Result = res
	return ec.marshalNCodeListItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCodeListItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_codelistUserAccessTemplates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CodeListItem_id(ctx, field)
			case "name":
				return ec.fieldContext_CodeListItem_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CodeListItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_telemetryLogs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_telemetryLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TelemetryLogs(rctx, fc.Args["filter"].(*string), fc.Args["upn"].(*string), fc.Args["createdFrom"].(*string), fc.Args["createdTo"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.LogItem)
	fc.Result = res
	return ec.marshalNLogItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐLogItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_telemetryLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LogItem_id(ctx, field)
			case "upn":
				return ec.fieldContext_LogItem_upn(ctx, field)
			case "data":
				return ec.fieldContext_LogItem_data(ctx, field)
			case "created":
				return ec.fieldContext_LogItem_created(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_telemetryLogs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_securityLogs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_securityLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SecurityLogs(rctx, fc.Args["filter"].(*string), fc.Args["upn"].(*string), fc.Args["createdFrom"].(*string), fc.Args["createdTo"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.LogItem)
	fc.Result = res
	return ec.marshalNLogItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐLogItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_securityLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LogItem_id(ctx, field)
			case "upn":
				return ec.fieldContext_LogItem_upn(ctx, field)
			case "data":
				return ec.fieldContext_LogItem_data(ctx, field)
			case "created":
				return ec.fieldContext_LogItem_created(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_securityLogs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_systemConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_systemConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SystemConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.SystemConfig)
	fc.Result = res
	return ec.marshalNSystemConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐSystemConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_systemConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "networkCidr":
				return ec.fieldContext_SystemConfig_networkCidr(ctx, field)
			case "lighthouses":
				return ec.fieldContext_SystemConfig_lighthouses(ctx, field)
			case "maximumCertificateValidity":
				return ec.fieldContext_SystemConfig_maximumCertificateValidity(ctx, field)
			case "aadConfig":
				return ec.fieldContext_SystemConfig_aadConfig(ctx, field)
			case "cliApiConfig":
				return ec.fieldContext_SystemConfig_cliApiConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SystemConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_users(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Users(rctx, fc.Args["name"].(*string), fc.Args["origin"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_users(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "upn":
				return ec.fieldContext_User_upn(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "description":
				return ec.fieldContext_User_description(ctx, field)
			case "userAccesses":
				return ec.fieldContext_User_userAccesses(ctx, field)
			case "origin":
				return ec.fieldContext_User_origin(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_users_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_servers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_servers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Servers(rctx, fc.Args["name"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.Server)
	fc.Result = res
	return ec.marshalNServer2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_servers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Server_id(ctx, field)
			case "name":
				return ec.fieldContext_Server_name(ctx, field)
			case "allowAutoUpdate":
				return ec.fieldContext_Server_allowAutoUpdate(ctx, field)
			case "description":
				return ec.fieldContext_Server_description(ctx, field)
			case "access":
				return ec.fieldContext_Server_access(ctx, field)
			case "serverOSAutoUpdatePolicy":
				return ec.fieldContext_Server_serverOSAutoUpdatePolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Server", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_servers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Me(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "upn":
				return ec.fieldContext_User_upn(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "description":
				return ec.fieldContext_User_description(ctx, field)
			case "userAccesses":
				return ec.fieldContext_User_userAccesses(ctx, field)
			case "origin":
				return ec.fieldContext_User_origin(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_server(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_server(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Server(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.Server)
	fc.Result = res
	return ec.marshalNServer2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_server(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Server_id(ctx, field)
			case "name":
				return ec.fieldContext_Server_name(ctx, field)
			case "allowAutoUpdate":
				return ec.fieldContext_Server_allowAutoUpdate(ctx, field)
			case "description":
				return ec.fieldContext_Server_description(ctx, field)
			case "access":
				return ec.fieldContext_Server_access(ctx, field)
			case "serverOSAutoUpdatePolicy":
				return ec.fieldContext_Server_serverOSAutoUpdatePolicy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Server", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_server_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "upn":
				return ec.fieldContext_User_upn(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "description":
				return ec.fieldContext_User_description(ctx, field)
			case "userAccesses":
				return ec.fieldContext_User_userAccesses(ctx, field)
			case "origin":
				return ec.fieldContext_User_origin(ctx, field)
			case "roles":
				return ec.fieldContext_User_roles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_group(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Group(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_group_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_groups(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Groups(rctx, fc.Args["name"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_groups_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_accessListenerTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_accessListenerTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AccessListenerTypes(rctx, fc.Args["name"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.AccessListenerType)
	fc.Result = res
	return ec.marshalNAccessListenerType2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_accessListenerTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_AccessListenerType_id(ctx, field)
			case "glyph":
				return ec.fieldContext_AccessListenerType_glyph(ctx, field)
			case "name":
				return ec.fieldContext_AccessListenerType_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccessListenerType", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_accessListenerTypes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_userAccessTemplate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userAccessTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserAccessTemplate(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.UserAccessTemplate)
	fc.Result = res
	return ec.marshalNUserAccessTemplate2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userAccessTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserAccessTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_UserAccessTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_UserAccessTemplate_description(ctx, field)
			case "groups":
				return ec.fieldContext_UserAccessTemplate_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_UserAccessTemplate_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_UserAccessTemplate_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_UserAccessTemplate_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_UserAccessTemplate_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserAccessTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userAccessTemplate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_userAccessTemplates(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userAccessTemplates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserAccessTemplates(rctx, fc.Args["name"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.UserAccessTemplate)
	fc.Result = res
	return ec.marshalNUserAccessTemplate2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplateᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userAccessTemplates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserAccessTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_UserAccessTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_UserAccessTemplate_description(ctx, field)
			case "groups":
				return ec.fieldContext_UserAccessTemplate_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_UserAccessTemplate_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_UserAccessTemplate_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_UserAccessTemplate_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_UserAccessTemplate_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserAccessTemplate", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userAccessTemplates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_firewallConfiguration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_firewallConfiguration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FirewallConfiguration(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.FwConfig)
	fc.Result = res
	return ec.marshalNFwConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_firewallConfiguration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FwConfig_id(ctx, field)
			case "name":
				return ec.fieldContext_FwConfig_name(ctx, field)
			case "fwConfigOuts":
				return ec.fieldContext_FwConfig_fwConfigOuts(ctx, field)
			case "fwConfigIns":
				return ec.fieldContext_FwConfig_fwConfigIns(ctx, field)
			case "changed":
				return ec.fieldContext_FwConfig_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FwConfig", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_firewallConfiguration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_firewallConfigurations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_firewallConfigurations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FirewallConfigurations(rctx, fc.Args["name"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.FwConfig)
	fc.Result = res
	return ec.marshalNFwConfig2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_firewallConfigurations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FwConfig_id(ctx, field)
			case "name":
				return ec.fieldContext_FwConfig_name(ctx, field)
			case "fwConfigOuts":
				return ec.fieldContext_FwConfig_fwConfigOuts(ctx, field)
			case "fwConfigIns":
				return ec.fieldContext_FwConfig_fwConfigIns(ctx, field)
			case "changed":
				return ec.fieldContext_FwConfig_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FwConfig", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_firewallConfigurations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Server_id(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Server) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Server_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Server_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Server",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Server_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Server) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Server_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Server_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Server",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Server_allowAutoUpdate(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Server) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Server_allowAutoUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowAutoUpdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Server_allowAutoUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Server",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Server_description(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Server) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Server_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Server_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Server",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Server_access(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Server) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Server_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.Access)
	fc.Result = res
	return ec.marshalNAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Server_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Server",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Access_id(ctx, field)
			case "name":
				return ec.fieldContext_Access_name(ctx, field)
			case "ipAddress":
				return ec.fieldContext_Access_ipAddress(ctx, field)
			case "fqdn":
				return ec.fieldContext_Access_fqdn(ctx, field)
			case "additionalHostnames":
				return ec.fieldContext_Access_additionalHostnames(ctx, field)
			case "description":
				return ec.fieldContext_Access_description(ctx, field)
			case "groups":
				return ec.fieldContext_Access_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_Access_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_Access_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_Access_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_Access_changed(ctx, field)
			case "listeners":
				return ec.fieldContext_Access_listeners(ctx, field)
			case "config":
				return ec.fieldContext_Access_config(ctx, field)
			case "punchBack":
				return ec.fieldContext_Access_punchBack(ctx, field)
			case "restrictiveNetwork":
				return ec.fieldContext_Access_restrictiveNetwork(ctx, field)
			case "statistics":
				return ec.fieldContext_Access_statistics(ctx, field)
			case "deviceInfo":
				return ec.fieldContext_Access_deviceInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Access", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Server_serverOSAutoUpdatePolicy(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.Server) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Server_serverOSAutoUpdatePolicy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerOSAutoUpdatePolicy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.ServerOSAutoUpdatePolicy)
	fc.Result = res
	return ec.marshalNServerOSAutoUpdatePolicy2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerOSAutoUpdatePolicy(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Server_serverOSAutoUpdatePolicy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Server",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "osAutoUpdateEnabled":
				return ec.fieldContext_ServerOSAutoUpdatePolicy_osAutoUpdateEnabled(ctx, field)
			case "osAutoUpdateHour":
				return ec.fieldContext_ServerOSAutoUpdatePolicy_osAutoUpdateHour(ctx, field)
			case "securityAutoUpdateEnabled":
				return ec.fieldContext_ServerOSAutoUpdatePolicy_securityAutoUpdateEnabled(ctx, field)
			case "allAutoUpdateEnabled":
				return ec.fieldContext_ServerOSAutoUpdatePolicy_allAutoUpdateEnabled(ctx, field)
			case "restartAfterUpdate":
				return ec.fieldContext_ServerOSAutoUpdatePolicy_restartAfterUpdate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerOSAutoUpdatePolicy", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerForAccess_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ServerForAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerForAccess_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerForAccess_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerForAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerForAccess_ipAddress(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ServerForAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerForAccess_ipAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IPAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerForAccess_ipAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerForAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerForAccess_description(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ServerForAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerForAccess_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerForAccess_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerForAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerForAccess_listeners(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ServerForAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerForAccess_listeners(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Listeners, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.AccessListener)
	fc.Result = res
	return ec.marshalNAccessListener2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerForAccess_listeners(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerForAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "listenPort":
				return ec.fieldContext_AccessListener_listenPort(ctx, field)
			case "protocol":
				return ec.fieldContext_AccessListener_protocol(ctx, field)
			case "forwardPort":
				return ec.fieldContext_AccessListener_forwardPort(ctx, field)
			case "forwardHost":
				return ec.fieldContext_AccessListener_forwardHost(ctx, field)
			case "accessListenerType":
				return ec.fieldContext_AccessListener_accessListenerType(ctx, field)
			case "description":
				return ec.fieldContext_AccessListener_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccessListener", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerForAccess_statistics(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ServerForAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerForAccess_statistics(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Statistics, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.AccessStatistic)
	fc.Result = res
	return ec.marshalOAccessStatistic2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessStatistic(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerForAccess_statistics(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerForAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isConnectd":
				return ec.fieldContext_AccessStatistic_isConnectd(ctx, field)
			case "isOverRestrictiveNetwork":
				return ec.fieldContext_AccessStatistic_isOverRestrictiveNetwork(ctx, field)
			case "lastContact":
				return ec.fieldContext_AccessStatistic_lastContact(ctx, field)
			case "lastContactFromNow":
				return ec.fieldContext_AccessStatistic_lastContactFromNow(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AccessStatistic", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerOSAutoUpdatePolicy_osAutoUpdateEnabled(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ServerOSAutoUpdatePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerOSAutoUpdatePolicy_osAutoUpdateEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OsAutoUpdateEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerOSAutoUpdatePolicy_osAutoUpdateEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerOSAutoUpdatePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerOSAutoUpdatePolicy_osAutoUpdateHour(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ServerOSAutoUpdatePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerOSAutoUpdatePolicy_osAutoUpdateHour(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OsAutoUpdateHour, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerOSAutoUpdatePolicy_osAutoUpdateHour(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerOSAutoUpdatePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerOSAutoUpdatePolicy_securityAutoUpdateEnabled(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ServerOSAutoUpdatePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerOSAutoUpdatePolicy_securityAutoUpdateEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SecurityAutoUpdateEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerOSAutoUpdatePolicy_securityAutoUpdateEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerOSAutoUpdatePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerOSAutoUpdatePolicy_allAutoUpdateEnabled(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ServerOSAutoUpdatePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerOSAutoUpdatePolicy_allAutoUpdateEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllAutoUpdateEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerOSAutoUpdatePolicy_allAutoUpdateEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerOSAutoUpdatePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServerOSAutoUpdatePolicy_restartAfterUpdate(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.ServerOSAutoUpdatePolicy) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServerOSAutoUpdatePolicy_restartAfterUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RestartAfterUpdate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServerOSAutoUpdatePolicy_restartAfterUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServerOSAutoUpdatePolicy",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SystemConfig_networkCidr(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.SystemConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SystemConfig_networkCidr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NetworkCidr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SystemConfig_networkCidr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SystemConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SystemConfig_lighthouses(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.SystemConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SystemConfig_lighthouses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lighthouses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.Lighthouse)
	fc.Result = res
	return ec.marshalNLighthouse2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐLighthouse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SystemConfig_lighthouses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SystemConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "publicIp":
				return ec.fieldContext_Lighthouse_publicIp(ctx, field)
			case "port":
				return ec.fieldContext_Lighthouse_port(ctx, field)
			case "ipAddress":
				return ec.fieldContext_Lighthouse_ipAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Lighthouse", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SystemConfig_maximumCertificateValidity(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.SystemConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SystemConfig_maximumCertificateValidity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaximumCertificateValidity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SystemConfig_maximumCertificateValidity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SystemConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SystemConfig_aadConfig(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.SystemConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SystemConfig_aadConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AadConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.AadConfig)
	fc.Result = res
	return ec.marshalNAadConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAadConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SystemConfig_aadConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SystemConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isEnabled":
				return ec.fieldContext_AadConfig_isEnabled(ctx, field)
			case "clientId":
				return ec.fieldContext_AadConfig_clientId(ctx, field)
			case "clientSecret":
				return ec.fieldContext_AadConfig_clientSecret(ctx, field)
			case "tenantId":
				return ec.fieldContext_AadConfig_tenantId(ctx, field)
			case "adminGroupObjectId":
				return ec.fieldContext_AadConfig_adminGroupObjectId(ctx, field)
			case "lastProcessingMessage":
				return ec.fieldContext_AadConfig_lastProcessingMessage(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AadConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SystemConfig_cliApiConfig(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.SystemConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SystemConfig_cliApiConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CliAPIConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.CliAPIConfig)
	fc.Result = res
	return ec.marshalNCliApiConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCliAPIConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SystemConfig_cliApiConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SystemConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "isEnabled":
				return ec.fieldContext_CliApiConfig_isEnabled(ctx, field)
			case "url":
				return ec.fieldContext_CliApiConfig_url(ctx, field)
			case "apiKey":
				return ec.fieldContext_CliApiConfig_apiKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CliApiConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_upn(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_upn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Upn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_upn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_description(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userAccesses(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_userAccesses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserAccesses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.UserAccess)
	fc.Result = res
	return ec.marshalNUserAccess2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_userAccesses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserAccess_id(ctx, field)
			case "name":
				return ec.fieldContext_UserAccess_name(ctx, field)
			case "description":
				return ec.fieldContext_UserAccess_description(ctx, field)
			case "groups":
				return ec.fieldContext_UserAccess_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_UserAccess_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_UserAccess_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_UserAccess_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_UserAccess_changed(ctx, field)
			case "userAccessTemplate":
				return ec.fieldContext_UserAccess_userAccessTemplate(ctx, field)
			case "accesses":
				return ec.fieldContext_UserAccess_accesses(ctx, field)
			case "serversForAccess":
				return ec.fieldContext_UserAccess_serversForAccess(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_origin(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_origin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Origin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_origin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_roles(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_roles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Roles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_roles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_id(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_description(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_groups(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_fwConfig(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_fwConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FwConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.FwConfig)
	fc.Result = res
	return ec.marshalNFwConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_fwConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FwConfig_id(ctx, field)
			case "name":
				return ec.fieldContext_FwConfig_name(ctx, field)
			case "fwConfigOuts":
				return ec.fieldContext_FwConfig_fwConfigOuts(ctx, field)
			case "fwConfigIns":
				return ec.fieldContext_FwConfig_fwConfigIns(ctx, field)
			case "changed":
				return ec.fieldContext_FwConfig_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FwConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_validFrom(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_validFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_validFrom(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_validTo(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_validTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_validTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_changed(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_changed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Changed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_changed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_userAccessTemplate(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_userAccessTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserAccessTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.UserAccessTemplate)
	fc.Result = res
	return ec.marshalNUserAccessTemplate2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_userAccessTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_UserAccessTemplate_id(ctx, field)
			case "name":
				return ec.fieldContext_UserAccessTemplate_name(ctx, field)
			case "description":
				return ec.fieldContext_UserAccessTemplate_description(ctx, field)
			case "groups":
				return ec.fieldContext_UserAccessTemplate_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_UserAccessTemplate_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_UserAccessTemplate_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_UserAccessTemplate_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_UserAccessTemplate_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserAccessTemplate", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_accesses(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_accesses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accesses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.Access)
	fc.Result = res
	return ec.marshalNAccess2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_accesses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Access_id(ctx, field)
			case "name":
				return ec.fieldContext_Access_name(ctx, field)
			case "ipAddress":
				return ec.fieldContext_Access_ipAddress(ctx, field)
			case "fqdn":
				return ec.fieldContext_Access_fqdn(ctx, field)
			case "additionalHostnames":
				return ec.fieldContext_Access_additionalHostnames(ctx, field)
			case "description":
				return ec.fieldContext_Access_description(ctx, field)
			case "groups":
				return ec.fieldContext_Access_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_Access_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_Access_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_Access_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_Access_changed(ctx, field)
			case "listeners":
				return ec.fieldContext_Access_listeners(ctx, field)
			case "config":
				return ec.fieldContext_Access_config(ctx, field)
			case "punchBack":
				return ec.fieldContext_Access_punchBack(ctx, field)
			case "restrictiveNetwork":
				return ec.fieldContext_Access_restrictiveNetwork(ctx, field)
			case "statistics":
				return ec.fieldContext_Access_statistics(ctx, field)
			case "deviceInfo":
				return ec.fieldContext_Access_deviceInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Access", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccess_serversForAccess(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccess) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccess_serversForAccess(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServersForAccess, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.ServerForAccess)
	fc.Result = res
	return ec.marshalNServerForAccess2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerForAccessᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccess_serversForAccess(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccess",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ServerForAccess_name(ctx, field)
			case "ipAddress":
				return ec.fieldContext_ServerForAccess_ipAddress(ctx, field)
			case "description":
				return ec.fieldContext_ServerForAccess_description(ctx, field)
			case "listeners":
				return ec.fieldContext_ServerForAccess_listeners(ctx, field)
			case "statistics":
				return ec.fieldContext_ServerForAccess_statistics(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServerForAccess", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessDeviceInfo_access(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessDeviceInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessDeviceInfo_access(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.Access)
	fc.Result = res
	return ec.marshalNAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccess(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessDeviceInfo_access(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessDeviceInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Access_id(ctx, field)
			case "name":
				return ec.fieldContext_Access_name(ctx, field)
			case "ipAddress":
				return ec.fieldContext_Access_ipAddress(ctx, field)
			case "fqdn":
				return ec.fieldContext_Access_fqdn(ctx, field)
			case "additionalHostnames":
				return ec.fieldContext_Access_additionalHostnames(ctx, field)
			case "description":
				return ec.fieldContext_Access_description(ctx, field)
			case "groups":
				return ec.fieldContext_Access_groups(ctx, field)
			case "fwConfig":
				return ec.fieldContext_Access_fwConfig(ctx, field)
			case "validFrom":
				return ec.fieldContext_Access_validFrom(ctx, field)
			case "validTo":
				return ec.fieldContext_Access_validTo(ctx, field)
			case "changed":
				return ec.fieldContext_Access_changed(ctx, field)
			case "listeners":
				return ec.fieldContext_Access_listeners(ctx, field)
			case "config":
				return ec.fieldContext_Access_config(ctx, field)
			case "punchBack":
				return ec.fieldContext_Access_punchBack(ctx, field)
			case "restrictiveNetwork":
				return ec.fieldContext_Access_restrictiveNetwork(ctx, field)
			case "statistics":
				return ec.fieldContext_Access_statistics(ctx, field)
			case "deviceInfo":
				return ec.fieldContext_Access_deviceInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Access", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessDeviceInfo_certificate(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessDeviceInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessDeviceInfo_certificate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Certificate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessDeviceInfo_certificate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessDeviceInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessDeviceInfo_caPublicKey(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessDeviceInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessDeviceInfo_caPublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CaPublicKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessDeviceInfo_caPublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessDeviceInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessDeviceInfo_lighthouseIp(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessDeviceInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessDeviceInfo_lighthouseIp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LighthouseIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessDeviceInfo_lighthouseIp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessDeviceInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessDeviceInfo_lighthousePort(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessDeviceInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessDeviceInfo_lighthousePort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LighthousePort, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessDeviceInfo_lighthousePort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessDeviceInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessDeviceInfo_lighthousePrivateIp(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessDeviceInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessDeviceInfo_lighthousePrivateIp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LighthousePrivateIP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessDeviceInfo_lighthousePrivateIp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessDeviceInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessTemplate_id(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessTemplate_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessTemplate_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessTemplate_name(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessTemplate_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessTemplate_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessTemplate_description(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessTemplate_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessTemplate_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessTemplate_groups(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessTemplate_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*gqlmodel.Group)
	fc.Result = res
	return ec.marshalNGroup2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessTemplate_groups(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Group_id(ctx, field)
			case "name":
				return ec.fieldContext_Group_name(ctx, field)
			case "description":
				return ec.fieldContext_Group_description(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Group", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessTemplate_fwConfig(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessTemplate_fwConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FwConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*gqlmodel.FwConfig)
	fc.Result = res
	return ec.marshalNFwConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessTemplate_fwConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FwConfig_id(ctx, field)
			case "name":
				return ec.fieldContext_FwConfig_name(ctx, field)
			case "fwConfigOuts":
				return ec.fieldContext_FwConfig_fwConfigOuts(ctx, field)
			case "fwConfigIns":
				return ec.fieldContext_FwConfig_fwConfigIns(ctx, field)
			case "changed":
				return ec.fieldContext_FwConfig_changed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FwConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessTemplate_validFrom(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessTemplate_validFrom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidFrom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessTemplate_validFrom(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessTemplate_validTo(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessTemplate_validTo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessTemplate_validTo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserAccessTemplate_changed(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserAccessTemplate) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserAccessTemplate_changed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Changed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserAccessTemplate_changed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserAccessTemplate",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserStatistic_date(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserStatistic_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserStatistic_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserStatistic_hour(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserStatistic_hour(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hour, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserStatistic_hour(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserStatistic_usersOnline(ctx context.Context, field graphql.CollectedField, obj *gqlmodel.UserStatistic) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserStatistic_usersOnline(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UsersOnline, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserStatistic_usersOnline(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserStatistic",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAadConfigData(ctx context.Context, obj interface{}) (gqlmodel.AadConfigData, error) {
	var it gqlmodel.AadConfigData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"isEnabled", "clientId", "clientSecret", "tenantId", "adminGroupObjectId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "isEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isEnabled"))
			it.IsEnabled, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "clientId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			it.ClientID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clientSecret":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
			it.ClientSecret, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tenantId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tenantId"))
			it.TenantID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adminGroupObjectId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminGroupObjectId"))
			it.AdminGroupObjectID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAccessDeviceData(ctx context.Context, obj interface{}) (gqlmodel.AccessDeviceData, error) {
	var it gqlmodel.AccessDeviceData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "deviceId", "deviceOSType", "deviceOS", "deviceSWVersion", "contacted"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceId"))
			it.DeviceID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceOSType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceOSType"))
			it.DeviceOSType, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceOS":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceOS"))
			it.DeviceOs, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "deviceSWVersion":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deviceSWVersion"))
			it.DeviceSWVersion, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "contacted":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contacted"))
			it.Contacted, err = ec.unmarshalODateTime2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAccessListenerData(ctx context.Context, obj interface{}) (gqlmodel.AccessListenerData, error) {
	var it gqlmodel.AccessListenerData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"listenPort", "protocol", "forwardPort", "forwardHost", "accessListenerTypeId", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "listenPort":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("listenPort"))
			it.ListenPort, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "protocol":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("protocol"))
			it.Protocol, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "forwardPort":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forwardPort"))
			it.ForwardPort, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "forwardHost":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("forwardHost"))
			it.ForwardHost, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accessListenerTypeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessListenerTypeId"))
			it.AccessListenerTypeID, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCliApiConfigData(ctx context.Context, obj interface{}) (gqlmodel.CliAPIConfigData, error) {
	var it gqlmodel.CliAPIConfigData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"enabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "enabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			it.Enabled, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFwConfigData(ctx context.Context, obj interface{}) (gqlmodel.FwConfigData, error) {
	var it gqlmodel.FwConfigData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "fwConfigOuts", "fwConfigIns"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "fwConfigOuts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fwConfigOuts"))
			it.FwConfigOuts, err = ec.unmarshalNFwConfigRuleData2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigRuleDataᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "fwConfigIns":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fwConfigIns"))
			it.FwConfigIns, err = ec.unmarshalNFwConfigRuleData2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigRuleDataᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFwConfigRuleData(ctx context.Context, obj interface{}) (gqlmodel.FwConfigRuleData, error) {
	var it gqlmodel.FwConfigRuleData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"port", "proto", "host", "groups"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "port":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("port"))
			it.Port, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "proto":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("proto"))
			it.Proto, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "host":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			it.Host, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "groups":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groups"))
			it.Groups, err = ec.unmarshalOGroupData2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupDataᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGroupData(ctx context.Context, obj interface{}) (gqlmodel.GroupData, error) {
	var it gqlmodel.GroupData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInviteUserData(ctx context.Context, obj interface{}) (gqlmodel.InviteUserData, error) {
	var it gqlmodel.InviteUserData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "upn", "name", "description", "roles", "userAccessTemplateId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "upn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("upn"))
			it.Upn, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "roles":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
			it.Roles, err = ec.unmarshalNString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "userAccessTemplateId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userAccessTemplateId"))
			it.UserAccessTemplateID, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputServerAccessData(ctx context.Context, obj interface{}) (gqlmodel.ServerAccessData, error) {
	var it gqlmodel.ServerAccessData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ipAddress", "additionalHostnames", "description", "groupsIds", "fwConfigId", "validTo", "listeners", "punchBack", "restrictiveNetwork"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ipAddress":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ipAddress"))
			it.IPAddress, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "additionalHostnames":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("additionalHostnames"))
			it.AdditionalHostnames, err = ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupsIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupsIds"))
			it.GroupsIds, err = ec.unmarshalNInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "fwConfigId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fwConfigId"))
			it.FwConfigID, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "validTo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validTo"))
			it.ValidTo, err = ec.unmarshalNDateTime2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "listeners":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("listeners"))
			it.Listeners, err = ec.unmarshalNAccessListenerData2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerDataᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "punchBack":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("punchBack"))
			it.PunchBack, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "restrictiveNetwork":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("restrictiveNetwork"))
			it.RestrictiveNetwork, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputServerData(ctx context.Context, obj interface{}) (gqlmodel.ServerData, error) {
	var it gqlmodel.ServerData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "allowAutoUpdate", "description", "access", "osAutoUpdatePolicy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allowAutoUpdate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowAutoUpdate"))
			it.AllowAutoUpdate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "access":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
			it.Access, err = ec.unmarshalOServerAccessData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerAccessData(ctx, v)
			if err != nil {
				return it, err
			}
		case "osAutoUpdatePolicy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("osAutoUpdatePolicy"))
			it.OsAutoUpdatePolicy, err = ec.unmarshalOServerOSAutoUpdatePolicyData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerOSAutoUpdatePolicyData(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputServerOSAutoUpdatePolicyData(ctx context.Context, obj interface{}) (gqlmodel.ServerOSAutoUpdatePolicyData, error) {
	var it gqlmodel.ServerOSAutoUpdatePolicyData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"osAutoUpdateEnabled", "osAutoUpdateHour", "securityAutoUpdateEnabled", "allAutoUpdateEnabled", "restartAfterUpdate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "osAutoUpdateEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("osAutoUpdateEnabled"))
			it.OsAutoUpdateEnabled, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "osAutoUpdateHour":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("osAutoUpdateHour"))
			it.OsAutoUpdateHour, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "securityAutoUpdateEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("securityAutoUpdateEnabled"))
			it.SecurityAutoUpdateEnabled, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "allAutoUpdateEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allAutoUpdateEnabled"))
			it.AllAutoUpdateEnabled, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "restartAfterUpdate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("restartAfterUpdate"))
			it.RestartAfterUpdate, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSystemConfigData(ctx context.Context, obj interface{}) (gqlmodel.SystemConfigData, error) {
	var it gqlmodel.SystemConfigData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"networkCidr"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "networkCidr":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("networkCidr"))
			it.NetworkCidr, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserAccessData(ctx context.Context, obj interface{}) (gqlmodel.UserAccessData, error) {
	var it gqlmodel.UserAccessData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "groupsIds", "fwConfigId", "validTo", "userAccessTemplateId", "entityId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupsIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupsIds"))
			it.GroupsIds, err = ec.unmarshalNInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "fwConfigId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fwConfigId"))
			it.FwConfigID, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "validTo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validTo"))
			it.ValidTo, err = ec.unmarshalNDateTime2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "userAccessTemplateId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userAccessTemplateId"))
			it.UserAccessTemplateID, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "entityId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("entityId"))
			it.EntityID, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserAccessTemplateData(ctx context.Context, obj interface{}) (gqlmodel.UserAccessTemplateData, error) {
	var it gqlmodel.UserAccessTemplateData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "groupsIds", "fwConfigId", "validTo", "deleted"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "groupsIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupsIds"))
			it.GroupsIds, err = ec.unmarshalNInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
		case "fwConfigId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fwConfigId"))
			it.FwConfigID, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "validTo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validTo"))
			it.ValidTo, err = ec.unmarshalNDateTime2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "deleted":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deleted"))
			it.Deleted, err = ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserData(ctx context.Context, obj interface{}) (gqlmodel.UserData, error) {
	var it gqlmodel.UserData
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "upn", "name", "description", "origin", "roles"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			it.ID, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "upn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("upn"))
			it.Upn, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "origin":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("origin"))
			it.Origin, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "roles":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roles"))
			it.Roles, err = ec.unmarshalNString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Entity(ctx context.Context, sel ast.SelectionSet, obj gqlmodel.Entity) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case gqlmodel.User:
		return ec._User(ctx, sel, &obj)
	case *gqlmodel.User:
		if obj == nil {
			return graphql.Null
		}
		return ec._User(ctx, sel, obj)
	case gqlmodel.Server:
		return ec._Server(ctx, sel, &obj)
	case *gqlmodel.Server:
		if obj == nil {
			return graphql.Null
		}
		return ec._Server(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj gqlmodel.Node) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case gqlmodel.FwConfig:
		return ec._FwConfig(ctx, sel, &obj)
	case *gqlmodel.FwConfig:
		if obj == nil {
			return graphql.Null
		}
		return ec._FwConfig(ctx, sel, obj)
	case gqlmodel.Group:
		return ec._Group(ctx, sel, &obj)
	case *gqlmodel.Group:
		if obj == nil {
			return graphql.Null
		}
		return ec._Group(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var aadConfigImplementors = []string{"AadConfig"}

func (ec *executionContext) _AadConfig(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.AadConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aadConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AadConfig")
		case "isEnabled":

			out.Values[i] = ec._AadConfig_isEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clientId":

			out.Values[i] = ec._AadConfig_clientId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clientSecret":

			out.Values[i] = ec._AadConfig_clientSecret(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tenantId":

			out.Values[i] = ec._AadConfig_tenantId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "adminGroupObjectId":

			out.Values[i] = ec._AadConfig_adminGroupObjectId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastProcessingMessage":

			out.Values[i] = ec._AadConfig_lastProcessingMessage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accessImplementors = []string{"Access"}

func (ec *executionContext) _Access(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.Access) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accessImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Access")
		case "id":

			out.Values[i] = ec._Access_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._Access_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ipAddress":

			out.Values[i] = ec._Access_ipAddress(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "fqdn":

			out.Values[i] = ec._Access_fqdn(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "additionalHostnames":

			out.Values[i] = ec._Access_additionalHostnames(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._Access_description(ctx, field, obj)

		case "groups":

			out.Values[i] = ec._Access_groups(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "fwConfig":

			out.Values[i] = ec._Access_fwConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "validFrom":

			out.Values[i] = ec._Access_validFrom(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "validTo":

			out.Values[i] = ec._Access_validTo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "changed":

			out.Values[i] = ec._Access_changed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "listeners":

			out.Values[i] = ec._Access_listeners(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "config":

			out.Values[i] = ec._Access_config(ctx, field, obj)

		case "punchBack":

			out.Values[i] = ec._Access_punchBack(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "restrictiveNetwork":

			out.Values[i] = ec._Access_restrictiveNetwork(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "statistics":

			out.Values[i] = ec._Access_statistics(ctx, field, obj)

		case "deviceInfo":

			out.Values[i] = ec._Access_deviceInfo(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accessDeviceImplementors = []string{"AccessDevice"}

func (ec *executionContext) _AccessDevice(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.AccessDevice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accessDeviceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccessDevice")
		case "name":

			out.Values[i] = ec._AccessDevice_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deviceId":

			out.Values[i] = ec._AccessDevice_deviceId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deviceOSType":

			out.Values[i] = ec._AccessDevice_deviceOSType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deviceOS":

			out.Values[i] = ec._AccessDevice_deviceOS(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deviceSWVersion":

			out.Values[i] = ec._AccessDevice_deviceSWVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "contacted":

			out.Values[i] = ec._AccessDevice_contacted(ctx, field, obj)

		case "osAutoUpdate":

			out.Values[i] = ec._AccessDevice_osAutoUpdate(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accessListenerImplementors = []string{"AccessListener"}

func (ec *executionContext) _AccessListener(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.AccessListener) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accessListenerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccessListener")
		case "listenPort":

			out.Values[i] = ec._AccessListener_listenPort(ctx, field, obj)

		case "protocol":

			out.Values[i] = ec._AccessListener_protocol(ctx, field, obj)

		case "forwardPort":

			out.Values[i] = ec._AccessListener_forwardPort(ctx, field, obj)

		case "forwardHost":

			out.Values[i] = ec._AccessListener_forwardHost(ctx, field, obj)

		case "accessListenerType":

			out.Values[i] = ec._AccessListener_accessListenerType(ctx, field, obj)

		case "description":

			out.Values[i] = ec._AccessListener_description(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accessListenerTypeImplementors = []string{"AccessListenerType"}

func (ec *executionContext) _AccessListenerType(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.AccessListenerType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accessListenerTypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccessListenerType")
		case "id":

			out.Values[i] = ec._AccessListenerType_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "glyph":

			out.Values[i] = ec._AccessListenerType_glyph(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._AccessListenerType_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var accessStatisticImplementors = []string{"AccessStatistic"}

func (ec *executionContext) _AccessStatistic(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.AccessStatistic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, accessStatisticImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AccessStatistic")
		case "isConnectd":

			out.Values[i] = ec._AccessStatistic_isConnectd(ctx, field, obj)

		case "isOverRestrictiveNetwork":

			out.Values[i] = ec._AccessStatistic_isOverRestrictiveNetwork(ctx, field, obj)

		case "lastContact":

			out.Values[i] = ec._AccessStatistic_lastContact(ctx, field, obj)

		case "lastContactFromNow":

			out.Values[i] = ec._AccessStatistic_lastContactFromNow(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var adminDashboardImplementors = []string{"AdminDashboard"}

func (ec *executionContext) _AdminDashboard(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.AdminDashboard) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminDashboardImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminDashboard")
		case "users":

			out.Values[i] = ec._AdminDashboard_users(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "servers":

			out.Values[i] = ec._AdminDashboard_servers(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "invitedUsers":

			out.Values[i] = ec._AdminDashboard_invitedUsers(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "userStatistics":

			out.Values[i] = ec._AdminDashboard_userStatistics(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cliApiConfigImplementors = []string{"CliApiConfig"}

func (ec *executionContext) _CliApiConfig(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.CliAPIConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cliApiConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CliApiConfig")
		case "isEnabled":

			out.Values[i] = ec._CliApiConfig_isEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":

			out.Values[i] = ec._CliApiConfig_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "apiKey":

			out.Values[i] = ec._CliApiConfig_apiKey(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var codeListItemImplementors = []string{"CodeListItem"}

func (ec *executionContext) _CodeListItem(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.CodeListItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, codeListItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CodeListItem")
		case "id":

			out.Values[i] = ec._CodeListItem_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._CodeListItem_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var configItemImplementors = []string{"ConfigItem"}

func (ec *executionContext) _ConfigItem(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.ConfigItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, configItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfigItem")
		case "maxDBRecords":

			out.Values[i] = ec._ConfigItem_maxDBRecords(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tenantId":

			out.Values[i] = ec._ConfigItem_tenantId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tenantName":

			out.Values[i] = ec._ConfigItem_tenantName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maxCertificateValidity":

			out.Values[i] = ec._ConfigItem_maxCertificateValidity(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "identityImportEnabled":

			out.Values[i] = ec._ConfigItem_identityImportEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var costUsageItemImplementors = []string{"CostUsageItem"}

func (ec *executionContext) _CostUsageItem(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.CostUsageItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, costUsageItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CostUsageItem")
		case "yearMonth":

			out.Values[i] = ec._CostUsageItem_yearMonth(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "upn":

			out.Values[i] = ec._CostUsageItem_upn(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isUser":

			out.Values[i] = ec._CostUsageItem_isUser(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hours":

			out.Values[i] = ec._CostUsageItem_hours(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cost":

			out.Values[i] = ec._CostUsageItem_cost(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var costUsageMonthItemImplementors = []string{"CostUsageMonthItem"}

func (ec *executionContext) _CostUsageMonthItem(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.CostUsageMonthItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, costUsageMonthItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CostUsageMonthItem")
		case "yearMonth":

			out.Values[i] = ec._CostUsageMonthItem_yearMonth(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cost":

			out.Values[i] = ec._CostUsageMonthItem_cost(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "costUsageItems":

			out.Values[i] = ec._CostUsageMonthItem_costUsageItems(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fwConfigImplementors = []string{"FwConfig", "Node"}

func (ec *executionContext) _FwConfig(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.FwConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fwConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FwConfig")
		case "id":

			out.Values[i] = ec._FwConfig_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._FwConfig_name(ctx, field, obj)

		case "fwConfigOuts":

			out.Values[i] = ec._FwConfig_fwConfigOuts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "fwConfigIns":

			out.Values[i] = ec._FwConfig_fwConfigIns(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "changed":

			out.Values[i] = ec._FwConfig_changed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fwConfigRuleImplementors = []string{"FwConfigRule"}

func (ec *executionContext) _FwConfigRule(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.FwConfigRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fwConfigRuleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FwConfigRule")
		case "port":

			out.Values[i] = ec._FwConfigRule_port(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "proto":

			out.Values[i] = ec._FwConfigRule_proto(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "host":

			out.Values[i] = ec._FwConfigRule_host(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "groups":

			out.Values[i] = ec._FwConfigRule_groups(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var groupImplementors = []string{"Group", "Node"}

func (ec *executionContext) _Group(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.Group) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Group")
		case "id":

			out.Values[i] = ec._Group_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._Group_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._Group_description(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var lighthouseImplementors = []string{"Lighthouse"}

func (ec *executionContext) _Lighthouse(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.Lighthouse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, lighthouseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Lighthouse")
		case "publicIp":

			out.Values[i] = ec._Lighthouse_publicIp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "port":

			out.Values[i] = ec._Lighthouse_port(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ipAddress":

			out.Values[i] = ec._Lighthouse_ipAddress(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var logItemImplementors = []string{"LogItem"}

func (ec *executionContext) _LogItem(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.LogItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogItem")
		case "id":

			out.Values[i] = ec._LogItem_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "upn":

			out.Values[i] = ec._LogItem_upn(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "data":

			out.Values[i] = ec._LogItem_data(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "created":

			out.Values[i] = ec._LogItem_created(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "systemConfigSave":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_systemConfigSave(ctx, field)
			})

		case "systemAadConfigSave":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_systemAadConfigSave(ctx, field)
			})

		case "systemCliApiConfigSave":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_systemCliApiConfigSave(ctx, field)
			})

		case "userInvite":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userInvite(ctx, field)
			})

		case "serverDelete":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_serverDelete(ctx, field)
			})

		case "userDelete":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userDelete(ctx, field)
			})

		case "serverSave":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_serverSave(ctx, field)
			})

		case "userSave":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userSave(ctx, field)
			})

		case "groupDelete":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_groupDelete(ctx, field)
			})

		case "groupSave":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_groupSave(ctx, field)
			})

		case "userAccessTemplateDelete":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userAccessTemplateDelete(ctx, field)
			})

		case "userAccessTemplateSave":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userAccessTemplateSave(ctx, field)
			})

		case "firewallConfigurationDelete":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_firewallConfigurationDelete(ctx, field)
			})

		case "firewallConfigurationSave":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_firewallConfigurationSave(ctx, field)
			})

		case "userAccessDelete":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userAccessDelete(ctx, field)
			})

		case "userAccessSave":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userAccessSave(ctx, field)
			})

		case "userDeviceSaveNote":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userDeviceSaveNote(ctx, field)
			})

		case "userDeviceDelete":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userDeviceDelete(ctx, field)
			})

		case "userDeviceCreate":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_userDeviceCreate(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	return out
}

var osAutoUpdateImplementors = []string{"OsAutoUpdate"}

func (ec *executionContext) _OsAutoUpdate(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.OsAutoUpdate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, osAutoUpdateImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OsAutoUpdate")
		case "osType":

			out.Values[i] = ec._OsAutoUpdate_osType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._OsAutoUpdate_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._OsAutoUpdate_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._OsAutoUpdate_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastUpdate":

			out.Values[i] = ec._OsAutoUpdate_lastUpdate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastUpdateOutput":

			out.Values[i] = ec._OsAutoUpdate_lastUpdateOutput(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lastUpdateSuccess":

			out.Values[i] = ec._OsAutoUpdate_lastUpdateSuccess(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "securityUpdatesCount":

			out.Values[i] = ec._OsAutoUpdate_securityUpdatesCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "otherUpdatesCount":

			out.Values[i] = ec._OsAutoUpdate_otherUpdatesCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "securityUpdates":

			out.Values[i] = ec._OsAutoUpdate_securityUpdates(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "otherUpdates":

			out.Values[i] = ec._OsAutoUpdate_otherUpdates(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "monthCostUsage":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_monthCostUsage(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "config":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_config(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "adminDashboard":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminDashboard(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "codelistGroups":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_codelistGroups(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "codelistFirewalls":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_codelistFirewalls(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "codelistUserAccessTemplates":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_codelistUserAccessTemplates(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "telemetryLogs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_telemetryLogs(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "securityLogs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_securityLogs(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "systemConfig":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_systemConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "users":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_users(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "servers":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_servers(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "me":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "server":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_server(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "group":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_group(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "groups":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_groups(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "accessListenerTypes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_accessListenerTypes(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "userAccessTemplate":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userAccessTemplate(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "userAccessTemplates":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userAccessTemplates(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "firewallConfiguration":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_firewallConfiguration(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "firewallConfigurations":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_firewallConfigurations(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	return out
}

var serverImplementors = []string{"Server", "Entity"}

func (ec *executionContext) _Server(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.Server) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serverImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Server")
		case "id":

			out.Values[i] = ec._Server_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._Server_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "allowAutoUpdate":

			out.Values[i] = ec._Server_allowAutoUpdate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._Server_description(ctx, field, obj)

		case "access":

			out.Values[i] = ec._Server_access(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "serverOSAutoUpdatePolicy":

			out.Values[i] = ec._Server_serverOSAutoUpdatePolicy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var serverForAccessImplementors = []string{"ServerForAccess"}

func (ec *executionContext) _ServerForAccess(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.ServerForAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serverForAccessImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServerForAccess")
		case "name":

			out.Values[i] = ec._ServerForAccess_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ipAddress":

			out.Values[i] = ec._ServerForAccess_ipAddress(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._ServerForAccess_description(ctx, field, obj)

		case "listeners":

			out.Values[i] = ec._ServerForAccess_listeners(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "statistics":

			out.Values[i] = ec._ServerForAccess_statistics(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var serverOSAutoUpdatePolicyImplementors = []string{"ServerOSAutoUpdatePolicy"}

func (ec *executionContext) _ServerOSAutoUpdatePolicy(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.ServerOSAutoUpdatePolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serverOSAutoUpdatePolicyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServerOSAutoUpdatePolicy")
		case "osAutoUpdateEnabled":

			out.Values[i] = ec._ServerOSAutoUpdatePolicy_osAutoUpdateEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "osAutoUpdateHour":

			out.Values[i] = ec._ServerOSAutoUpdatePolicy_osAutoUpdateHour(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "securityAutoUpdateEnabled":

			out.Values[i] = ec._ServerOSAutoUpdatePolicy_securityAutoUpdateEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "allAutoUpdateEnabled":

			out.Values[i] = ec._ServerOSAutoUpdatePolicy_allAutoUpdateEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "restartAfterUpdate":

			out.Values[i] = ec._ServerOSAutoUpdatePolicy_restartAfterUpdate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var systemConfigImplementors = []string{"SystemConfig"}

func (ec *executionContext) _SystemConfig(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.SystemConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, systemConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SystemConfig")
		case "networkCidr":

			out.Values[i] = ec._SystemConfig_networkCidr(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lighthouses":

			out.Values[i] = ec._SystemConfig_lighthouses(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maximumCertificateValidity":

			out.Values[i] = ec._SystemConfig_maximumCertificateValidity(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "aadConfig":

			out.Values[i] = ec._SystemConfig_aadConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cliApiConfig":

			out.Values[i] = ec._SystemConfig_cliApiConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User", "Entity"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":

			out.Values[i] = ec._User_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "upn":

			out.Values[i] = ec._User_upn(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._User_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._User_description(ctx, field, obj)

		case "userAccesses":

			out.Values[i] = ec._User_userAccesses(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "origin":

			out.Values[i] = ec._User_origin(ctx, field, obj)

		case "roles":

			out.Values[i] = ec._User_roles(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userAccessImplementors = []string{"UserAccess"}

func (ec *executionContext) _UserAccess(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.UserAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userAccessImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserAccess")
		case "id":

			out.Values[i] = ec._UserAccess_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._UserAccess_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._UserAccess_description(ctx, field, obj)

		case "groups":

			out.Values[i] = ec._UserAccess_groups(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "fwConfig":

			out.Values[i] = ec._UserAccess_fwConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "validFrom":

			out.Values[i] = ec._UserAccess_validFrom(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "validTo":

			out.Values[i] = ec._UserAccess_validTo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "changed":

			out.Values[i] = ec._UserAccess_changed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "userAccessTemplate":

			out.Values[i] = ec._UserAccess_userAccessTemplate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "accesses":

			out.Values[i] = ec._UserAccess_accesses(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "serversForAccess":

			out.Values[i] = ec._UserAccess_serversForAccess(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userAccessDeviceInfoImplementors = []string{"UserAccessDeviceInfo"}

func (ec *executionContext) _UserAccessDeviceInfo(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.UserAccessDeviceInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userAccessDeviceInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserAccessDeviceInfo")
		case "access":

			out.Values[i] = ec._UserAccessDeviceInfo_access(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "certificate":

			out.Values[i] = ec._UserAccessDeviceInfo_certificate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "caPublicKey":

			out.Values[i] = ec._UserAccessDeviceInfo_caPublicKey(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lighthouseIp":

			out.Values[i] = ec._UserAccessDeviceInfo_lighthouseIp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lighthousePort":

			out.Values[i] = ec._UserAccessDeviceInfo_lighthousePort(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lighthousePrivateIp":

			out.Values[i] = ec._UserAccessDeviceInfo_lighthousePrivateIp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userAccessTemplateImplementors = []string{"UserAccessTemplate"}

func (ec *executionContext) _UserAccessTemplate(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.UserAccessTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userAccessTemplateImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserAccessTemplate")
		case "id":

			out.Values[i] = ec._UserAccessTemplate_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._UserAccessTemplate_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._UserAccessTemplate_description(ctx, field, obj)

		case "groups":

			out.Values[i] = ec._UserAccessTemplate_groups(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "fwConfig":

			out.Values[i] = ec._UserAccessTemplate_fwConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "validFrom":

			out.Values[i] = ec._UserAccessTemplate_validFrom(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "validTo":

			out.Values[i] = ec._UserAccessTemplate_validTo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "changed":

			out.Values[i] = ec._UserAccessTemplate_changed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userStatisticImplementors = []string{"UserStatistic"}

func (ec *executionContext) _UserStatistic(ctx context.Context, sel ast.SelectionSet, obj *gqlmodel.UserStatistic) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userStatisticImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserStatistic")
		case "date":

			out.Values[i] = ec._UserStatistic_date(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hour":

			out.Values[i] = ec._UserStatistic_hour(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "usersOnline":

			out.Values[i] = ec._UserStatistic_usersOnline(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAadConfig2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAadConfig(ctx context.Context, sel ast.SelectionSet, v gqlmodel.AadConfig) graphql.Marshaler {
	return ec._AadConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNAadConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAadConfig(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.AadConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AadConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAadConfigData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAadConfigData(ctx context.Context, v interface{}) (gqlmodel.AadConfigData, error) {
	res, err := ec.unmarshalInputAadConfigData(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAccess2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccess(ctx context.Context, sel ast.SelectionSet, v gqlmodel.Access) graphql.Marshaler {
	return ec._Access(ctx, sel, &v)
}

func (ec *executionContext) marshalNAccess2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.Access) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccess(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.Access) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Access(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAccessDeviceData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessDeviceData(ctx context.Context, v interface{}) (gqlmodel.AccessDeviceData, error) {
	res, err := ec.unmarshalInputAccessDeviceData(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAccessListener2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.AccessListener) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccessListener2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListener(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAccessListener2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListener(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.AccessListener) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AccessListener(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAccessListenerData2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerDataᚄ(ctx context.Context, v interface{}) ([]*gqlmodel.AccessListenerData, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*gqlmodel.AccessListenerData, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAccessListenerData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerData(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNAccessListenerData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerData(ctx context.Context, v interface{}) (*gqlmodel.AccessListenerData, error) {
	res, err := ec.unmarshalInputAccessListenerData(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAccessListenerType2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.AccessListenerType) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAccessListenerType2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAccessListenerType2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerType(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.AccessListenerType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AccessListenerType(ctx, sel, v)
}

func (ec *executionContext) marshalNAdminDashboard2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAdminDashboard(ctx context.Context, sel ast.SelectionSet, v gqlmodel.AdminDashboard) graphql.Marshaler {
	return ec._AdminDashboard(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminDashboard2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAdminDashboard(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.AdminDashboard) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminDashboard(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCliApiConfig2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCliAPIConfig(ctx context.Context, sel ast.SelectionSet, v gqlmodel.CliAPIConfig) graphql.Marshaler {
	return ec._CliApiConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNCliApiConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCliAPIConfig(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.CliAPIConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CliApiConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCliApiConfigData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCliAPIConfigData(ctx context.Context, v interface{}) (gqlmodel.CliAPIConfigData, error) {
	res, err := ec.unmarshalInputCliApiConfigData(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCodeListItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCodeListItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.CodeListItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCodeListItem2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCodeListItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCodeListItem2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCodeListItem(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.CodeListItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CodeListItem(ctx, sel, v)
}

func (ec *executionContext) marshalNConfigItem2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐConfigItem(ctx context.Context, sel ast.SelectionSet, v gqlmodel.ConfigItem) graphql.Marshaler {
	return ec._ConfigItem(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfigItem2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐConfigItem(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.ConfigItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConfigItem(ctx, sel, v)
}

func (ec *executionContext) marshalNCostUsageItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCostUsageItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.CostUsageItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCostUsageItem2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCostUsageItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCostUsageItem2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCostUsageItem(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.CostUsageItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CostUsageItem(ctx, sel, v)
}

func (ec *executionContext) marshalNCostUsageMonthItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCostUsageMonthItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.CostUsageMonthItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCostUsageMonthItem2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCostUsageMonthItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCostUsageMonthItem2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐCostUsageMonthItem(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.CostUsageMonthItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CostUsageMonthItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDateTime2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNFwConfig2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfig(ctx context.Context, sel ast.SelectionSet, v gqlmodel.FwConfig) graphql.Marshaler {
	return ec._FwConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNFwConfig2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.FwConfig) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFwConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFwConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfig(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.FwConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FwConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFwConfigData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigData(ctx context.Context, v interface{}) (gqlmodel.FwConfigData, error) {
	res, err := ec.unmarshalInputFwConfigData(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFwConfigRule2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigRuleᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.FwConfigRule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFwConfigRule2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFwConfigRule2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigRule(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.FwConfigRule) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FwConfigRule(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFwConfigRuleData2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigRuleDataᚄ(ctx context.Context, v interface{}) ([]*gqlmodel.FwConfigRuleData, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*gqlmodel.FwConfigRuleData, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFwConfigRuleData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigRuleData(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNFwConfigRuleData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐFwConfigRuleData(ctx context.Context, v interface{}) (*gqlmodel.FwConfigRuleData, error) {
	res, err := ec.unmarshalInputFwConfigRuleData(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGroup2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroup(ctx context.Context, sel ast.SelectionSet, v gqlmodel.Group) graphql.Marshaler {
	return ec._Group(ctx, sel, &v)
}

func (ec *executionContext) marshalNGroup2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.Group) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroup2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGroup2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroup(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.Group) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Group(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGroupData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupData(ctx context.Context, v interface{}) (gqlmodel.GroupData, error) {
	res, err := ec.unmarshalInputGroupData(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNGroupData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupData(ctx context.Context, v interface{}) (*gqlmodel.GroupData, error) {
	res, err := ec.unmarshalInputGroupData(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2ᚕintᚄ(ctx context.Context, v interface{}) ([]int, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInviteUserData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐInviteUserData(ctx context.Context, v interface{}) (gqlmodel.InviteUserData, error) {
	res, err := ec.unmarshalInputInviteUserData(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLighthouse2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐLighthouse(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.Lighthouse) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOLighthouse2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐLighthouse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNLogItem2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐLogItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.LogItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLogItem2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐLogItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLogItem2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐLogItem(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.LogItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogItem(ctx, sel, v)
}

func (ec *executionContext) marshalNServer2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServer(ctx context.Context, sel ast.SelectionSet, v gqlmodel.Server) graphql.Marshaler {
	return ec._Server(ctx, sel, &v)
}

func (ec *executionContext) marshalNServer2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.Server) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServer2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServer2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServer(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.Server) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Server(ctx, sel, v)
}

func (ec *executionContext) marshalNServerForAccess2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerForAccessᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.ServerForAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNServerForAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerForAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNServerForAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerForAccess(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.ServerForAccess) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServerForAccess(ctx, sel, v)
}

func (ec *executionContext) marshalNServerOSAutoUpdatePolicy2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerOSAutoUpdatePolicy(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.ServerOSAutoUpdatePolicy) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ServerOSAutoUpdatePolicy(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) marshalNSystemConfig2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐSystemConfig(ctx context.Context, sel ast.SelectionSet, v gqlmodel.SystemConfig) graphql.Marshaler {
	return ec._SystemConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNSystemConfig2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐSystemConfig(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.SystemConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SystemConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSystemConfigData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐSystemConfigData(ctx context.Context, v interface{}) (gqlmodel.SystemConfigData, error) {
	res, err := ec.unmarshalInputSystemConfigData(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v gqlmodel.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUser(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserAccess2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccess(ctx context.Context, sel ast.SelectionSet, v gqlmodel.UserAccess) graphql.Marshaler {
	return ec._UserAccess(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserAccess2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.UserAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserAccess2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccess(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.UserAccess) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserAccess(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserAccessData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessData(ctx context.Context, v interface{}) (gqlmodel.UserAccessData, error) {
	res, err := ec.unmarshalInputUserAccessData(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserAccessDeviceInfo2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessDeviceInfo(ctx context.Context, sel ast.SelectionSet, v gqlmodel.UserAccessDeviceInfo) graphql.Marshaler {
	return ec._UserAccessDeviceInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserAccessDeviceInfo2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessDeviceInfo(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.UserAccessDeviceInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserAccessDeviceInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNUserAccessTemplate2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplate(ctx context.Context, sel ast.SelectionSet, v gqlmodel.UserAccessTemplate) graphql.Marshaler {
	return ec._UserAccessTemplate(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserAccessTemplate2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplateᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.UserAccessTemplate) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUserAccessTemplate2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUserAccessTemplate2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplate(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.UserAccessTemplate) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserAccessTemplate(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUserAccessTemplateData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserAccessTemplateData(ctx context.Context, v interface{}) (gqlmodel.UserAccessTemplateData, error) {
	res, err := ec.unmarshalInputUserAccessTemplateData(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUserData2githubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserData(ctx context.Context, v interface{}) (gqlmodel.UserData, error) {
	res, err := ec.unmarshalInputUserData(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUserStatistic2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserStatistic(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.UserStatistic) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOUserStatistic2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserStatistic(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAccessDevice2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessDevice(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.AccessDevice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AccessDevice(ctx, sel, v)
}

func (ec *executionContext) marshalOAccessListenerType2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessListenerType(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.AccessListenerType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AccessListenerType(ctx, sel, v)
}

func (ec *executionContext) marshalOAccessStatistic2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐAccessStatistic(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.AccessStatistic) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AccessStatistic(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalODateTime2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODateTime2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOGroup2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupᚄ(ctx context.Context, sel ast.SelectionSet, v []*gqlmodel.Group) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroup2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGroupData2ᚕᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupDataᚄ(ctx context.Context, v interface{}) ([]*gqlmodel.GroupData, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*gqlmodel.GroupData, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGroupData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐGroupData(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOLighthouse2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐLighthouse(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.Lighthouse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Lighthouse(ctx, sel, v)
}

func (ec *executionContext) marshalOOsAutoUpdate2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐOsAutoUpdate(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.OsAutoUpdate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OsAutoUpdate(ctx, sel, v)
}

func (ec *executionContext) unmarshalOServerAccessData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerAccessData(ctx context.Context, v interface{}) (*gqlmodel.ServerAccessData, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputServerAccessData(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOServerData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerData(ctx context.Context, v interface{}) (*gqlmodel.ServerData, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputServerData(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOServerOSAutoUpdatePolicyData2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐServerOSAutoUpdatePolicyData(ctx context.Context, v interface{}) (*gqlmodel.ServerOSAutoUpdatePolicyData, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputServerOSAutoUpdatePolicyData(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOUserStatistic2ᚖgithubᚗcomᚋshieldooᚋshieldooᚑmeshᚑadminᚋgraphᚋmodelᚐUserStatistic(ctx context.Context, sel ast.SelectionSet, v *gqlmodel.UserStatistic) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserStatistic(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
